import{z as M,m as p,az as c,r as m,b as T,v as D,t as n,aA as z,a2 as U,aB as A}from"./lib.Cdm3KEls.js";async function v(){let a=new U;a.setMessage(n("输入")+n("行数")+":"),a.setUserInputControls(A.kNoZeroResponseAccepted|A.kNoNegativeResponseAccepted);let l=await a.go();if(l==null)return;a.setMessage(n("输入")+n("列数")+":");let f=await a.go();if(f==null)return;let s=await M.getCorner(n("输入")+n("偏移距离"));if(!s)return;let i=s.pt2.x-s.pt1.x,o=s.pt2.y-s.pt1.y,x=await M.userSelect(n("选择")+n("陈列对象")),e=M.getMcDbEntitysBoundingBox(x);if(!e)return;let t=new p;i>0?t.x=e.minPt.x:t.x=e.maxPt.x,o>0?t.y=e.minPt.y:t.y=e.maxPt.y,b({iColNum:f,iRowNum:l,dColOffset:i,dRowOffset:o,aryId:x,dAng:0})}const b=a=>{const{iRowNum:l=0,iColNum:f=0,dColOffset:s=0,dRowOffset:i=0,aryId:o=[],dAng:x=0}=a;let e=M.getMcDbEntitysBoundingBox(o);if(!e)return;let t=new p;s>0?t.x=e.minPt.x:t.x=e.maxPt.x,i>0?t.y=e.minPt.y:t.y=e.maxPt.y;let g=new c().setToRotation(x*Math.PI/180,m.kZAxis,t),P=5e4,C=0;for(let y=0;y<l;y++){let B=new m(0,i*y,0),N=new c().setToTranslation(B);for(let u=0;u<f;u++){if(y==0&&u==0)continue;let R=new m(s*u,0,0),I=new c().setToTranslation(R),r=new p(t.x,t.y,t.z);r.transformBy(N),r.transformBy(I),r.transformBy(g);let O=new c().setToTranslation(new m(r.x-t.x,r.y-t.y,r.z-t.z));for(let w=0;w<o.length;w++){let d=o[w].clone();if(d&&(d.transformBy(O),T.getCurrentMxCAD().drawEntity(d),C++,C>P)){D.acutPrintf(n("超出最大阵列对象个数")+P+n("限制")+`
`);return}}z()}}};export{v as M,b as r};
