var Kt=Object.defineProperty;var zt=(t,e,o)=>e in t?Kt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o;var G=(t,e,o)=>zt(t,typeof e!="symbol"?e+"":e,o);import{i as Ot,a as pe,s as Ft,g as me,c as Ae,b as $,t as u,d as ht,e as _,f as Q,h as Te,j,k as W,l as Bt,m as z,n as H,o as R,p as ae,q as ee,r as Z,u as J,v as I,w as nt,x as Fe,y as le,D as T,z as B,A as Ze,B as mt,C as ct,E as Pe,F as Ve,G as xt,H as Ut,I as Ht,J as jt,K as ke,L as Re,N as Xt,O as it,P as Je,Q as _e,R as Pt,S as pt,T as lt,U as fe,V as At,W as Mt,X as Yt,_ as he,Y as Le,Z as Gt,$ as Dt,a0 as qt,a1 as Zt,a2 as bt,a3 as ue,a4 as ve,a5 as ot,a6 as Ct,a7 as Ge,a8 as st,a9 as dt,aa as Qe,ab as Jt,ac as Qt,ad as en,ae as kt,af as Et,ag as ut,ah as tn,ai as nn,aj as sn,ak as on,al as rn,am as an,an as et,ao as cn,ap as ln,aq as dn,ar as un}from"./lib.DTykjivu.js";import{M as gn}from"./index.CefkIasv.js";import{s as fn}from"./hooks.C9N3R9Vz.js";import{p as yn}from"./print.C1A5-esz.js";import{d as wn}from"./hooks.BEMLZH-J.js";import{u as vt}from"./hooks.B4e6XVV9.js";import{u as hn}from"./useMultilineTextDialog.D8lpyHRz.js";import"./framework.BMMljfWr.js";import"./commonjsHelpers.Cpj98o6Y.js";const mn=(t=!1,e=!1,o=!1)=>new Promise(async(s,r)=>{let d;d=$.App.getCurrentMxCAD().getCurrentOriginaFileName(),d.length==0?d="temp_empty"+me(!0):d.indexOf(".")==-1?d+=me(!0):d.substring(d.length-6)!=me(!0)&&(d+=me(!0));let c=d;!$.App.getCurrentMxCAD().saveFile(d,async n=>{let i;/^((?!chrome|android).)*safari/i.test(navigator.userAgent)?i=new Blob([n.buffer],{type:"application/octet-stream"}):i=new Blob([n.buffer],{type:"application/octet-binary"});try{s({blob:i,data:n,filename:c})}catch(M){r(M),console.error(M)}},e,o,t?void 0:{compression:0})&&r(u("mxweb文件保存失败"))}),It=async()=>{try{if(!Ot()){const t=pe(),{filename:e,blob:o,data:s}=await mn(!0,!1,!1);await Ft({blob:o,filename:e,types:[{description:"webcad File",accept:{"application/octet-stream":[me(!0)]}}]}),t&&Ae("MxFullScreen")}}catch(t){console.error(t)}},xn=async()=>{await It()};async function Pn(t,e){let o=t+"_preloading.json",s=await ht.getJsonFromUrl(o),r={ok:!0,tz:!1};if(!s)return new Promise((a,n)=>{a(r)});s.tz&&(r.tz=s.tz);let d=[];if(s.images.forEach(a=>{a.substring(0,5)!="http:"&&a.substring(0,6)!="https:"&&d.push(a)}),s.images=d,s.images.length===0&&s.externalReference.length===0)return new Promise((a,n)=>{a(r)});s.hash=e;const c=await fn(s);return c!=null&&c.data?r.ok=!0:r.ok=!1,new Promise((a,n)=>{a(r)})}const pn=async()=>{const t=new Q;t.setMessage(u("选择需要离散的实体"));let e;t.setUserDraw(a=>{e=a});const o=await t.go();if(!o||!o.isValid())return;let s=o.getMcDbCurve();if(!s||!(s instanceof Te))return;const r=new j;r.setUserDraw((a,n)=>{if(!s||!e)return;const i=s.clone();i&&(i.move(e,a),n.drawMcDbEntity(i))});const d=await r.go();if(!d)return;let c=s.clone();if(c)if(c.move(e,d),s instanceof W){const a=$.getCurrentMxCAD().drawEntity(c);let n=new Bt;n.copyFormAryId([a]),$.App.MxCADAssist.MxExplode(n.imp)}else{const a=c.getSamplePoints(.1);if(a.GetCount()===0)return;let n;const i=$.getCurrentMxCAD();a.forEach((l,M)=>{if(M===1010){const D=new z(l.x,l.y,l.z);if(n){const P=new H;P.startPoint=n,P.endPoint=D,P.colorIndex=c.colorIndex,P.trueColor=c.trueColor,P.drawOrder=c.drawOrder,P.layer=c.layer,P.layerId=c.layerId,P.linetype=c.linetype,P.linetypeScale=c.linetypeScale,P.lineweight=P.lineweight,P.textStyle=P.textStyle,i.drawEntity(P)}n=D}}),i.updateDisplay()}};_("_SampleCurve",pn);function Ne(t,e,o){const s=e.clone(),r=o.clone(),d=t.clone(),c=d.sub(s),a=r.sub(s),n=d.sub(r);let i,l=c.crossProduct(a).length()/a.length(),M=c.dotProduct(a);const D=a.clone().mult(M/a.length()**2);return s.clone().addvec(D),M<0?i=c.length():M>Math.pow(a.length(),2)?i=n.length():i=l,Math.floor(i)}const An=async()=>{var i;const t=$.getCurrentMxCAD(),e=new j;e.setMessage(u("指定第一条尺寸界线原点")),e.setKeyWords("");let o=await e.go(),s,r;if(e.getStatus()===R.kNone){const l=new Q,M=new ae;M.AddMcDbEntityTypes("CIRCLE,ARC,LINE,LWPOLYLINE");let D;const P=(y,x)=>{D=y;const g=B.findEntAtPoint(y.x,y.y,y.z,-1,M);if(!(g&&g.isValid()))return;const f=g.getMcDbEntity();f&&(r&&r.highlight(!1),f.highlight(!0),r=f)};for(;;){l.setMessage(u("选择标注对象")),l.setUserDraw(P),l.setFilter(M);const x=(await l.go()).getMcDbEntity();if(r&&r.highlight(!1),l.getStatus()===R.kCancel)return;if(x instanceof ee){const g=x.getStartPoint().val,f=x.radius,h=Z.kXAxis.clone().rotateBy(x.endAngle).mult(f),m=x.center.clone().addvec(h);if(!g||!m)return;o=g,s=m;break}else if(x instanceof J){const g=x.center,f=x.getStartPoint().val;if(!f)return;o=f,s=f.clone().addvec(g.sub(f).mult(2));break}else if(x instanceof H){o=x.startPoint,s=x.endPoint;break}else if(x instanceof W){for(let g=0;g<x.numVerts();g++){const f=x.getPointAt(g).val,h=x.getPointAt(g+1).val,w=x.getClosestPointTo(D,!1).val;h&&Ne(w,f,h)===0&&(o=f,s=h)}break}else{I.acutPrintf(`
`+u("所选对象不是直线、圆弧或圆"));continue}}}if(!o||!s&&(e.setMessage(u("指定第二条尺寸界线原点")),e.setUserDraw((l,M)=>{o&&M.drawMcDbLine(o.x,o.y,o.z,l.x,l.y,l.z)}),s=await e.go(),!s))return;let d,c,a,n;for(;;){e.setMessage(u("指定尺寸线位置")),e.setKeyWords(`[${u("文本")}(T)/${u("角度")}(A)${typeof n>"u"?u("水平")+"/(H)/"+u("垂直")+"(V)":""}/${u("旋转")}(R)]`),e.clearLastInputPoint();let l;const M=o.clone(),D=s.clone();let P,y;e.setUserDraw(f=>{if(!o||!s)return;l&&l.erase(),r instanceof J&&(P||(P=r.center.clone().addvec(Z.kXAxis.clone().rotateBy(Math.PI/2).mult(r.radius))),y||(y=r.center.clone().addvec(Z.kXAxis.clone().rotateBy(-Math.PI/2).mult(r.radius))),f.y<P.y&&f.y>y.y&&(f.x>o.x||f.x<s.x)&&(o=P,s=y),f.x<M.x&&f.x>D.x&&(f.y>P.y||f.y<y.y)&&(o=M,s=D)),n==="H"&&(f.x<o.x?f.x=o.x:f.x>s.x&&(f.x=s.x)),n==="V"&&(f.y<o.y&&(f.y=o.y),f.y>s.y&&(f.y=s.y)),l=t.drawDimRotated(o.x,o.y,s.x,s.y,f.x,f.y,a||0);const h=l.getMcDbDimension();h&&(h.textPosition=f,h.useSetTextPosition(),d&&(h.dimensionText=d),c&&(h.textRotation=c),h.trueColor=new nt(0,255,0))});const x=await e.go();if(e.isKeyWordPicked("T")){const f=new Fe;f.clearLastInputPoint(),f.setMessage(`${u("输入标注文字")}<${d||((i=l.getMcDbDimension())==null?void 0:i.dimensionText)||""}>`),f.setKeyWords("");const h=await f.go();if(typeof h!="string")return;d=h,l&&l.erase();continue}if(l&&l.erase(),e.isKeyWordPicked("A")){const f=new le;f.clearLastInputPoint(),f.setMessage(u("指定标注文字的角度"));const h=await f.go();if(!h||f.getStatus()===R.kCancel)return;f.getDetailedResult()===T.kCoordIn?c=h*(Math.PI/180):c=h;continue}if(e.isKeyWordPicked("H")){n="H";continue}if(e.isKeyWordPicked("V")){n="V";continue}if(e.isKeyWordPicked("R")){const f=new le;f.clearLastInputPoint(),f.setMessage(u("指定尺寸线的角度"));const h=await f.go();if(!h||f.getStatus()===R.kCancel)return;f.getDetailedResult()===T.kCoordIn?a=h*(Math.PI/180):a=h;continue}if(!x)return;n==="H"&&(x.x<o.x?x.x=o.x:x.x>s.x&&(x.x=s.x)),n==="V"&&(x.y<o.y&&(x.y=o.y),x.y>s.y&&(x.y=s.y)),l=t.drawDimRotated(o.x,o.y,s.x,s.y,x.x,x.y,a||0);const g=l.getMcDbDimension();if(!g)return;g.textPosition=x,g.useSetTextPosition(),d&&(g.dimensionText=d),c&&(g.textRotation=c),g.trueColor=new nt(0,255,0),t.updateDisplay();break}};_("_DrawRotatedDimension",An);const Mn=async()=>{var c;const t=$.getCurrentMxCAD();console.log(t.drawDimStyle);const e=new j;e.setMessage(`${u("指定第一条尺寸界线原点")}<${u("选择对象")}>`),e.setKeyWords("");let o=await e.go(),s;if(e.getStatus()===R.kNone){const a=new Q,n=new ae;n.AddMcDbEntityTypes("CIRCLE,ARC,LINE,LWPOLYLINE");let i,l;const M=(D,P)=>{i=D;const y=B.findEntAtPoint(D.x,D.y,D.z,-1,n);if(!(y&&y.isValid()))return;const x=y.getMcDbEntity();x&&(l&&l.highlight(!1),x.highlight(!0),l=x)};for(;;){a.setMessage(u("选择标注对象")),a.setUserDraw(M),a.setFilter(n);const P=(await a.go()).getMcDbEntity();if(l&&l.highlight(!1),a.getStatus()===R.kCancel)return;if(P instanceof ee){const y=P.getStartPoint().val,x=P.radius,g=Z.kXAxis.clone().rotateBy(P.endAngle).mult(x),h=P.center.clone().addvec(g);if(!y||!h)return;o=y,s=h;break}else if(P instanceof J){const y=P.center,x=P.getClosestPointTo(i,!1).val;if(!x)return;o=x,s=x.clone().addvec(y.sub(x).mult(2));break}else if(P instanceof H){o=P.startPoint,s=P.endPoint;break}else if(P instanceof W){for(let y=0;y<P.numVerts();y++){const x=P.getPointAt(y).val,g=P.getPointAt(y+1).val,f=P.getClosestPointTo(i,!1).val;g&&Ne(f,x,g)===0&&(o=x,s=g)}break}else{I.acutPrintf(`
`+u("所选对象不是直线、圆弧或圆"));continue}}}if(!o||!s&&(e.setMessage(u("指定第二条尺寸界线原点")),e.setUserDraw((a,n)=>{o&&n.drawMcDbLine(o.x,o.y,o.z,a.x,a.y,a.z)}),s=await e.go(),!s))return;let r,d;for(;;){e.setMessage(u("指定尺寸线位置")),e.setKeyWords(`[${u("文本")}(T)/${u("角度")}(A)]`),e.clearLastInputPoint();let a;e.setUserDraw(l=>{if(!o||!s)return;a&&a.erase(),a=t.drawDimAligned(o.x,o.y,s.x,s.y,l.x,l.y);const M=a.getMcDbDimension();M&&(r&&(M.dimensionText=r),d&&(M.textRotation=d))});const n=await e.go();if(e.isKeyWordPicked("T")){const l=new Fe;l.clearLastInputPoint(),l.setMessage(`${u("输入标注文字")}<${r||((c=a.getMcDbDimension())==null?void 0:c.dimensionText)||""}>`),l.setKeyWords("");const M=await l.go();if(typeof M!="string")return;r=M,a&&a.erase();continue}if(a&&a.erase(),e.isKeyWordPicked("A")){const l=new le;l.clearLastInputPoint(),l.setMessage(u("指定标注文字的角度"));const M=await l.go();if(!M||l.getStatus()===R.kCancel)return;l.getDetailedResult()===T.kCoordIn?d=M*(Math.PI/180):d=M;continue}if(!n)return;a=t.drawDimAligned(o.x,o.y,s.x,s.y,n.x,n.y);const i=a.getMcDbDimension();if(!i)return;i.textPosition=n,r&&(i.dimensionText=r),d&&(i.textRotation=d),t.updateDisplay();break}};_("_DrawAlignedDimension",Mn);async function Dn(){let t=I.getCurrentDraw().getViewAngle();t-=Math.PI*.5,$.getCurrentMxCAD().zoomAngle(t)}async function bn(){const t=new Ze;t.setMessage(u("输入选项")),t.setKeyWords(`[${u("当前")} UCS(C)/${u("世界")}(W)/${u("角度")}(A)/${u("相对角度")}(X)]`);const e=await t.go();if(e==null||e.toLocaleLowerCase(),e==null||e.toLocaleLowerCase(),(e==null?void 0:e.toLocaleLowerCase())==="a"){const o=new le;o.clearLastInputPoint(),o.setMessage(u("输入视区旋转角度"));let s=await o.go();if(!s)return;o.getDetailedResult()===T.kCoordIn&&(s=s*(Math.PI/180)),$.getCurrentMxCAD().zoomAngle(s)}if((e==null?void 0:e.toLocaleLowerCase())==="x"){const o=new le;o.clearLastInputPoint(),o.setMessage(u("输入视区旋转相对角度"));let s=await o.go();if(!s)return;o.getDetailedResult()===T.kCoordIn&&(s=s*(Math.PI/180));let r=I.getCurrentDraw().getViewAngle();r+=s,$.getCurrentMxCAD().zoomAngle(r)}}_("Mx_Plan90CCW",Dn);_("Mx_Plan",bn);function Cn(){const t=$.getCurrentMxCAD();let e=t.mxdraw.getViewColor();const{createColor:o}=mt();Ae("Mx_Color",{color:o({color:ct(e).toString()}),call:s=>{const r=ct(s),d=r.red(),c=r.green(),a=r.blue();t.setViewBackgroundColor(d,c,a),I.callEvent("updateBackgroundColor",new nt(d,c,a))}})}_("_ViewColor",Cn);function Lt(t,e){const o=document.timeline?document.timeline.currentTime:performance.now();let s=!1;function r(d){if(s)return;const c=d-o,a=Math.round(c/t);e(a);const n=(a+1)*t+o,i=document.timeline?document.timeline.currentTime:performance.now();return setTimeout(()=>{requestAnimationFrame(r)},n-i)}return r(o),()=>{s=!0}}function St(t,e,o){let s=e,r=o;for(;r-s>1e-4;){let c=(s+r)/2;Math.floor(t/c)*c>t||c<e?r=c:s=c}let d=Math.floor(t/s);return t/d}function Se(t,e,o,s){const r=t.distanceTo(e),d=[],c=St(r,o,s);if(isNaN(c))return d;const a=r/c,n=e.sub(t).normalize();for(let i=0;i<a;i++)d.push(t.clone().addvec(n.clone().mult(c*i)));return d}function kn(t=new z,e=new z,o=3,s=Math.PI*2){const r=[];o=Math.max(3,o),r.push(e);const d=s/o;for(let c=1;c<o;c++){const a=Math.cos(d*c),n=Math.sin(d*c),i=t.clone(),l=e.clone(),M=l.x-i.x,D=l.y-i.y,P=M*a-D*n+i.x,y=M*n+D*a+i.y,x=new z(P,y);r.push(x)}return r}const En=(t,e)=>{const o=new z(t.x,e.y,t.z),s=new z(e.x,t.y,e.z);return[t,o,e,s]};async function vn(){const t=I.viewCoordLong2Cad(2);let e=Number(localStorage.getItem("mx_revcloud_minArcLength")),o=Number(localStorage.getItem("mx_revcloud_maxArcLength"));if(isNaN(e)||e<1e-4){const i=I.viewCoordLong2Cad(12);localStorage.setItem("mx_revcloud_minArcLength",i.toString())}if(isNaN(o)||o<1e-4){const i=I.viewCoordLong2Cad(12);localStorage.setItem("mx_revcloud_maxArcLength",i.toString())}const s=new j;let r=-.45,d=!1,c=!1,a=!1;function n(i,l){i.colorIndex=l.colorIndex,i.trueColor=l.trueColor,i.drawOrder=l.drawOrder,i.layer=l.layer,i.layerId=l.layerId,i.linetype=l.linetype,i.linetypeScale=l.linetypeScale,i.lineweight=l.lineweight,i.textStyle=l.textStyle}for(;;){let i=u("第一点");d&&(i=u("指定第一个角点")),c&&(i=u("指定起点")),s.setMessage(i),s.setKeyWords(`[${u("弧长")}(A)/${u("对象")}(O)/${u("矩形")}(R)/${u("多边形")}(P)/${u("徒手画")}(F)/${u("样式")}(S)]`);const l=new W;s.clearLastInputPoint();const M=async P=>{if(s.clearLastInputPoint(),s.setMessage(u("反转方向")),s.setKeyWords(`[${u("是")}(Y)/${u("否")}(N)]`),await s.go(),s.isKeyWordPicked("Y")){const y=P.numVerts();for(let x=0;x<y;x++){const g=P.getBulgeAt(x);P.setBulgeAt(x,-g)}}return!0};let D=await s.go();if(s.isKeyWordPicked("A")){const P=new Pe;P.setMessage(u("请输入最小弧长"));let y=await P.go();if(typeof y!="number")return;if(y<1e-5){I.acutPrintf(`
`+u("指定最小弧度长度过小"));return}e=y,localStorage.setItem("mx_revcloud_minArcLength",y.toString());const x=async()=>{P.setMessage(u("指定最大弧长"));let g=await P.go();if(typeof g!="number")return!1;if(g<1e-5){I.acutPrintf(`
`+u("指定最大弧度长度过小"));return}if(g<e)return I.acutPrintf(`
`+u("指定最大弧度比最小弧度还小，无效")),await x();o=g,localStorage.setItem("mx_revcloud_maxArcLength",g.toString())};if(await x()===!1)return;continue}if(s.isKeyWordPicked("O")){const P=new ae;P.AddMcDbEntityTypes("CIRCLE,ARC,LINE,LWPOLYLINE,ELLIPSE");const x=(await B.userSelect(u("选择对象"),P))[0];if(!x)return;const g=x.getMcDbEntity();if(!g)return;if(g instanceof W){l.isClosed=g.isClosed,l.constantWidth=g.constantWidth,n(l,g);const f=g.numVerts();let h;for(let w=0;w<f;w++){const m=g.getPointAt(w).val;h&&m&&Se(h,m,e,o).forEach(p=>{l.addVertexAt(p,r,void 0,a?t:void 0)}),h=m}return l.isClosed?Se(h,g.getPointAt(0).val,e,o).forEach(w=>{l.addVertexAt(w,r,void 0,a?t:void 0)}):l.addVertexAt(h,r),await M(l),g.erase(),$.getCurrentMxCAD().drawEntity(l)}if(g instanceof H)return n(l,g),Se(g.startPoint,g.endPoint,e,o).forEach(f=>{l.addVertexAt(f,r,void 0,a?t:void 0)}),l.addVertexAt(g.endPoint,r,void 0,a?t:void 0),await M(l),g.erase(),$.getCurrentMxCAD().drawEntity(l);if(g instanceof J){const f=g.getLength().val,h=f/St(f,e,o),w=g.getStartPoint().val;return kn(g.center,w,h).forEach(m=>{l.addVertexAt(m,r,void 0,a?t:void 0)}),n(l,g),g instanceof J&&(l.isClosed=!0),await M(l),g.erase(),$.getCurrentMxCAD().drawEntity(l)}}if(s.isKeyWordPicked("R")){d=!0,c=!1;continue}if(s.isKeyWordPicked("P")){c=!0,d=!1;continue}if(s.isKeyWordPicked("F")){c=!1,d=!1;continue}if(s.isKeyWordPicked("S")){if(s.setMessage(u("选择圆弧样式")),s.setKeyWords(`[${u("普通")}(N)/${u("手绘")}(C)]`),await s.go(),s.getDetailedResult()===T.kEcsIn||s.getDetailedResult()===T.kNewCommadIn||s.getStatus()===R.kNone||s.getStatus()===R.kCancel)return;s.isKeyWordPicked("N")&&(a=!1),s.isKeyWordPicked("C")&&(a=!0);continue}if(!D)return;if(d){s.setMessage(u("指定对角点")),s.setMessage("");const P=(x,g)=>{if(!D)return;const[f,h,w,m]=En(D,g),p=D.x<g.x&&D.y<g.y||D.x>g.x&&D.y>g.y;[[f,h],[h,w],[w,m],[m,f]].forEach(([A,b])=>{Se(A,b,e,o).forEach(C=>{x.addVertexAt(C,p?r:-r,void 0,a?t:void 0)})}),x.isClosed=!0};s.setUserDraw((x,g)=>{const f=new W;P(f,x),g.drawMcDbEntity(f)});const y=await s.go();return y?(P(l,y),$.getCurrentMxCAD().drawEntity(l)):void 0}else if(c){let P=D;const y=[];y.push(P);const x=(g,f)=>{let h;f.forEach(w=>{h&&Se(h,w,e,o).forEach(m=>{g.addVertexAt(m,r,void 0,a?t:void 0)}),h=w}),f.length>2?(g.isClosed=!0,Se(h,f[0],e,o).forEach(w=>{g.addVertexAt(w,r,void 0,a?t:void 0)})):g.addVertexAt(h,r,void 0,a?t:void 0)};for(s.setUserDraw((g,f)=>{const h=new W;x(h,[...y,g]),f.drawMcDbEntity(h)});;){s.setMessage(u("指定下一点")),s.setKeyWords(y.length<2?"":`[${u("放弃")}(U)]`);const g=await s.go();if(s.isKeyWordPicked("U")){y.pop(),s.clearLastInputPoint();continue}if(s.getDetailedResult()===T.kNullEnterIn||s.getDetailedResult()===T.kMouseRightIn)return x(l,y),await M(l),$.getCurrentMxCAD().drawEntity(l);if(!g)return;y.push(g)}}else{l.addVertexAt(D,r,void 0,a?t:void 0);const P=D.clone();let y=0,x=D;const g=async()=>{h(),await M(l),$.getCurrentMxCAD().drawEntity(l)};s.setMessage(u("沿云线路径引导十字光标")+"..."),s.setKeyWords(""),s.setUserDraw((m,p)=>{D&&(x=m,y=D.distanceTo(m),p.drawMcDbEntity(l.clone()),p.drawLine(D.toVector3(),m.toVector3()))}),s.clearLastInputPoint();let f=!1;const h=Lt(20,async()=>{if(!(y<e)){if(x.distanceTo(P)<e){l.isClosed=!0,I.stopRunCommand(),f=!0;return}l.addVertexAt(x,r,void 0,a?t:void 0),D=x,y=0}}),w=await s.go();if((s.getDetailedResult()===T.kMouseRightIn||s.getDetailedResult()===T.kNullEnterIn)&&await g(),!w&&!f)return h();w&&l.addVertexAt(w,r,void 0,a?t:void 0),await g();break}}}_("_Revcloud",vn);async function In(){const t=pe(),e=()=>{t&&Ae("MxFullScreen")},o=(a,n,i=210,l=297,M=0)=>{let{baseUrl:D="",mxfilepath:P="",printPdfUrl:y=""}=Ut()||{},x={width:""+i,height:""+l,roate_angle:M,bd_pt1_x:""+a.x,bd_pt1_y:""+a.y,bd_pt2_x:""+n.x,bd_pt2_y:""+n.y};$.getCurrentMxCAD().saveFileToUrl(y,(g,f)=>{try{let h=JSON.parse(f);if(h.ret=="ok"){let w=D+P+h.file;yn(w),e()}else console.log(f)}catch{console.log("Mx: sserverResult error")}},void 0,JSON.stringify(x))};I.acutPrintf(`
`+u("请框选范围打印"));let s=$.getCurrentMxCAD(),r=0,d=!1;for(;;){let a=new j;a.setMessage(`
`+u("指定输出范围第一点")+":"),a.setKeyWords(`[${u("按比例打印")}(S)/[${u("图纸横向")}(D)]`),a.disableAllTrace();let n=await a.go();if(a.isKeyWordPicked("D"))d=!0;else if(a.isKeyWordPicked("S")){let i=new Ze;i.setMessage(u("输入图纸大小")),i.setKeyWords(`[A1(A)/A2(B)/A3(C)/A4(D)/${u("自定义")}16.55x23.90(E)]`),i.setDisableDynInput(!0);const l=await i.go();if(!l)return;let M={A:{w:594,h:841},B:{w:420,h:594},C:{w:297,h:420},D:{w:210,h:297},E:{w:165.5,h:239,nw:130,nh:190}};if(!M[l])return;let D=new Fe;D.setMessage(`${u("输入打印比例")}(${u("图纸上一个毫米对应的CAD绘图单位")})`);let P=await D.go();if(!P)return;var c=parseFloat(P);if(isNaN(c)){I.acutPrintf(u("输入的比例不对"));return}let y=M[l].w*c,x=M[l].h*c,g=0,f=0;if(M[l].nw&&(g=M[l].nw*c),M[l].nh&&(f=M[l].nh*c),d){let p=y;y=x,x=p,p=g,g=f,f=p}a=new j,a.disableAllTrace(),a.setMessage(`
`+u("指定指定打印中心位置")),a.setKeyWords(""),a.setUserDraw((p,A)=>{A.setColor(16711680);let b=new W,C=new z(p.x-y*.5,p.y-x*.5),k=new z(p.x-y*.5,p.y+x*.5),E=new z(p.x+y*.5,p.y+x*.5),S=new z(p.x+y*.5,p.y-x*.5);b.addVertexAt(C),b.addVertexAt(k),b.addVertexAt(E),b.addVertexAt(S),b.constantWidth=I.screenCoordLong2Doc(2),b.isClosed=!0,A.drawMcDbEntity(b);let v=[];if(v.push(C.toVector3()),v.push(k.toVector3()),v.push(E.toVector3()),v.push(S.toVector3()),A.setColor(12868),A.drawSolid(v,.5),g>0&&f>0){let L=new z(p.x-g*.5,p.y-f*.5),V=new z(p.x-g*.5,p.y+f*.5),K=new z(p.x+g*.5,p.y+f*.5),F=new z(p.x+g*.5,p.y-f*.5),N=[];N.push(L.toVector3()),N.push(V.toVector3()),N.push(K.toVector3()),N.push(F.toVector3()),N.push(L.toVector3());let U=s.mxdraw.viewCoordLong2Cad(3),X=Ve.createDashedLines(N,16777215,U*2,U);A.drawEntity(X)}});let h=await a.go();if(!h)return e();let w=new z(h.x-y*.5,h.y-x*.5),m=new z(h.x+y*.5,h.y+x*.5);o(w,m,d?M[l].h:M[l].w,d?M[l].w:M[l].h,r);return}else{if(!n)return e();a.setMessage(`
`+u("指定输出范围第二点")+":"),a.setUserDraw((l,M)=>{if(!n)return e();M.setColor(16711680);let D=new W;D.addVertexAt(n),D.addVertexAt(new z(n.x,l.y)),D.addVertexAt(l),D.addVertexAt(new z(l.x,n.y)),D.constantWidth=I.screenCoordLong2Doc(2),D.isClosed=!0,M.drawMcDbEntity(D);let P=[];P.push(n.toVector3()),P.push(new THREE.Vector3(n.x,l.y)),P.push(l.toVector3()),P.push(new THREE.Vector3(l.x,n.y)),M.setColor(12868),M.drawSolid(P,.5)}),a.setDisableOsnap(!0),a.setDisableOrthoTrace(!0),a.setDynamicInputType(xt.kXYCoordInput);let i=await a.go();if(!i)return e();o(n,i,d?297:210,d?210:297,r);return}}}_("Plot",In);async function Ln(){const t=I.viewCoordLong2Cad(20),e=new j;e.setDisableDynInput(!0),e.setDynamicInputType(xt.kNoInput);let o=await e.go();if(!o)return;const s=new W;let r=0,d=o;const c=Lt(20,()=>{r<t||(s.addVertexAt(d),o=d,r=0)});e.setUserDraw((i,l)=>{o&&(d=i,r=o.distanceTo(i),l.drawMcDbEntity(s.clone()),l.drawLine(o.toVector3(),i.toVector3()))});const a=await e.go();if(!a)return c();c(),s.addVertexAt(a),$.getCurrentMxCAD().drawEntity(s)}_("MxET_Pencil",Ln);function Sn(t){const e=t.requestFullscreen||t.mozRequestFullScreen||t.webkitRequestFullScreen||t.msRequestFullscreen;e?e.call(t):(ke().error(u("当前浏览器不支持部分全屏")+"!"),console.error(u("当前浏览器不支持部分全屏")+"!"))}function Tn(){const t=document.exitFullscreen||document.mozCancelFullScreen||document.webkitExitFullscreen||document.msExitFullscreen;t?t.call(document):(ke().error(u("当前浏览器不支持部分全屏")+"!"),console.error(u("当前浏览器不支持部分全屏")+"!"))}window.addEventListener("keydown",t=>{t.keyCode===122&&(t.returnValue=!1,Ae("MxFullScreen"))},!0);Ht.register({key:{keyCode:"Escape"},when(t){return t.isRunCommand?!1:pe()},action(){Ae("MxFullScreen")}});_("MxFullScreen",()=>{if(pe())Tn(),"keyboard"in navigator&&navigator.keyboard.unlock();else{const t=jt();Sn(typeof t=="string"?document.body:t),"keyboard"in navigator&&navigator.keyboard.lock()}});async function Rn(){const t=new Pe;t.setMessage(u("指定圆环的内径"));const e=await t.go();if(!e)return;t.setMessage(u("指定圆环的外径"));const o=await t.go();if(!o)return;const s=new j;s.clearLastInputPoint(),s.setMessage(u("指定圆环的中心点")),s.setUserDraw((M,D)=>{const P=new J,y=new J;P.radius=e/2,y.radius=o/2,P.center=M,y.center=M,D.drawMcDbEntity(P),D.drawMcDbEntity(y)});const r=await s.go();if(!r)return;const d=Math.abs(e-o)/4,c=Math.min(e,o),a=r.clone().addvec(Z.kXAxis.clone().mult(c/2+d)),n=r.clone().addvec(Z.kXAxis.clone().negate().mult(c/2+d)),i=new W,l=1;i.addVertexAt(a,l),i.addVertexAt(n,l),i.addVertexAt(a,l),i.isClosed=!0,i.constantWidth=d*2,$.getCurrentMxCAD().drawEntity(i)}_("_donut",Rn);function We(t,e,o=0){const s=t.numVerts();for(let r=0;r<t.numVerts();r++){const d=t.getPointAt(r).val;let c=t.getPointAt(r+1).val;if(t.getBulgeAt(r)===0){if(r+1===s&&t.isClosed&&(c=t.getPointAt(0).val),c&&Ne(e,d,c)<o)return{start:d,end:c,startIndex:r,endIndex:r+1}}else if(c){const n=t.getParamAtPoint(d).val,i=t.getParamAtPoint(c).val,l=t.getParamAtPoint(e).val;if(i>l&&l>n)return{start:d,end:c,startIndex:r,endIndex:r+1}}}if(t.isClosed){const r=t.getPointAt(0).val,d=t.getPointAt(t.numVerts()-1).val;if(Ne(e,d,r)<o)return{start:d,end:r,startIndex:t.numVerts()-1,endIndex:0,isClosed:!0}}}async function Vn(){var g,f;const t=$.getCurrentMxCAD(),e=new Q;let o,s,r,d,c,a;const n=new ae;n.AddMcDbEntityTypes("CIRCLE,ARC,LINE,LWPOLYLINE");let i,l;const M=(h,w)=>{i=h;const m=B.findEntAtPoint(h.x,h.y,h.z,-1,n);if(!(m&&m.isValid()))return;const p=m.getMcDbEntity();p&&(l&&l.highlight(!1),p.highlight(!0),l=p)};for(;;){e.setMessage(`${u("选择")}${u("圆弧")}、${u("圆")}、${u("直线")}${u("或")} <${u("指定顶点")}>`),e.setUserDraw(M),e.setFilter(n);const w=(await e.go()).getMcDbEntity();if(l&&l.highlight(!1),e.getStatus()===R.kCancel)return;if(e.getStatus()===R.kNone){const m=new j;m.clearLastInputPoint(),m.setMessage(u("指定角顶点"));const p=await m.go();if(!p)return;m.setBasePt(p),m.setMessage(u("指定角的第一个端点"));const A=await m.go();if(!A)return;m.setMessage(u("指定角的第二个端点"));const b=await m.go();if(!b)return;o=p.x,s=p.y,r=A.x,d=A.y,c=b.x,a=b.y;break}else if(w instanceof ee){const m=w.getStartPoint().val,p=w.radius,A=Z.kXAxis.clone().rotateBy(w.endAngle).mult(p),b=w.center,C=b.clone().addvec(A);if(!m||!C)return;r=m.x,d=m.y,c=C.x,a=C.y,o=b.x,s=b.y;break}else if(w instanceof J){const m=w.center;o=m.x,s=m.y,r=i.x,d=i.y;const p=new j;p.setMessage(u("指定角的第二个端点"));const A=await p.go();if(!A)return;const b=w.getClosestPointTo(A,!1).val;c=b.x,a=b.y;break}else if(w instanceof H||w instanceof W){const m=new Q,p=new ae;p.AddMcDbEntityTypes("LINE,LWPOLYLINE"),m.setFilter(p);let A;l=null,m.setUserDraw((k,E)=>{M(k),A=k});const b=w.getClosestPointTo(i,!1).val;let C;if(r=b.x,d=b.y,w instanceof H)C=w,C.highlight(!0);else{const{start:k,end:E}=We(w,b,2)||{};k&&E&&(C=new H(k,E)),w.highlight(!1)}if(!C)return;for(;;){m.setMessage(u("选择第二条直线"));const k=await m.go();if(m.getStatus()===R.kCancel)return C.highlight(!1);if(!k||!k.isValid())continue;let E=k.getMcDbEntity(),S;if(E instanceof W){const{start:K,end:F}=We(E,m.getDocPickPoint(),2)||{};S=new H(K,F),E.highlight(!1)}else if(E instanceof H)S=E;else{I.acutPrintf(`
`+u("所选对象不是直线"));continue}if(!S)return C.highlight(!1);C.highlight(!1),S.highlight(!1);const v=(g=C.clone())==null?void 0:g.IntersectWith(S.clone(),Re.Intersect.kExtendBoth);if(v.isEmpty())continue;const L=v.at(0),V=S.getClosestPointTo(A,!1).val;c=V.x,a=V.y,o=L.x,s=L.y;break}break}}const D=new j;D.clearLastInputPoint();let P,y,x;if(![o,s,r,d,c,a].some(h=>typeof h!="number"))for(;;){D.setMessage(u("指定标注弧线位置")),D.setKeyWords(`[${u("文字")}(T)/${u("角度")}(A)/${u("象限点")}(Q)]`),D.setUserDraw((m,p)=>{let A=new Xt;A.compute(o,s,r,d,c,a,m.x,m.y),y&&(A.dimensionText=y),x&&(A.textRotation=x),p.drawMcDbEntity(A,!0)});const h=await D.go();if(D.isKeyWordPicked("T")){const m=new Fe;m.clearLastInputPoint(),m.setMessage(`${u("输入")}${u("标注文字")}<${y||((f=P.getMcDbDimension())==null?void 0:f.dimensionText)||""}>`),m.setKeyWords("");const p=await m.go();if(typeof p!="string")return;y=p;continue}if(D.isKeyWordPicked("A")){const m=new le;m.clearLastInputPoint(),m.setMessage(u("指定标注文字的角度"));const p=await m.go();if(!p||m.getStatus()===R.kCancel)return;m.getDetailedResult()===T.kCoordIn?x=p*(Math.PI/180):x=p;continue}if(D.isKeyWordPicked("Q"),!h)return;t.drawUseDefaultProperties=!0,P=t.drawDimAngular(o,s,r,d,c,a,h.x,h.y);const w=P.getMcDbDimension();if(!w)return;y&&(w.dimensionText=y),x&&(w.textRotation=x);return}}_("_dimangular",Vn);function gt(t,e,o){const{x:s,y:r}=e,{x:d,y:c}=o,{x:a,y:n}=t,i=Math.min(s,d),l=Math.min(r,c),M=Math.max(s,d),D=Math.max(r,c);return a>=i&&a<=M&&n>=l&&n<=D}function tt(t,e,o,s,r){let d=e.sub(t);const c=o.distanceTo(s)===0;o.x>s.x||(d=d.negate()),r.forEach(n=>{if(!n)return;const i=n.getGripPoints();if(!i.isEmpty()){if((n instanceof ee||n instanceof J||n instanceof _e)&&(gt(n.center,o,s)||c)){n.move(t,e);return}i.forEach((l,M)=>{if(gt(l,o,s)&&!((n instanceof ee||n instanceof _e||n instanceof J)&&n.center.isEqualTo(l))&&!(n instanceof H&&M===2)){if(n instanceof W&&i.length()!==n.numVerts()){const D=n.numVerts();let P=0;for(let y=0;y<D;y++){if(n.getPointAt(y).val,n.getBulgeAt(y)!==0&&(P++,P===M))return;P++}}n.moveGripPointsAt(M,d.x,d.y,d.z)}})}})}const Ue=it(0,"_stretch_offsetX"),He=it(0,"_stretch_offsetY"),je=it(0,"_stretch_offsetZ");async function _n(){const t=new Je;let e=B.getCurrentSelect(),o,s;if(e.length<=0){if(!await t.userSelect(u("选择对象")))return;e=t.getIds();const i=t.getSelectPoint();o=i.pt1,s=i.pt2}else{const{point1:i,point2:l}=B.getCurrentSelectPoints();o=i,s=l}const r=new j;r.setMessage(`
`+u("指定基点")),r.setKeyWords(`[${u("位移")}(D)]`);const d=await r.go(),c=async i=>{if(!(typeof i>"u"&&(r.setMessage(`
${u("指定位移")}<${Ue.value}, ${He.value}, ${je.value}>`),r.setKeyWords(""),r.clearLastInputPoint(),i=await r.go(),!i))){if(i){const{x:l,y:M,z:D}=i;Ue.value=l,He.value=M,je.value=D}else{if(Ue.value===0&&He.value===0&&je.value===0)return;i=new z(Ue.value,He.value,je.value)}tt(new z,i,o,s,e.map(l=>l.getMcDbEntity()))}};if(r.isKeyWordPicked("D")||r.getStatus()===R.kNone)return await c();if(!d)return;r.setMessage(`
${u("指定第二个点")}${u("或")}<${u("使用第一个点作为位移")}>`),r.setBasePt(d),r.setKeyWords(""),r.setUserDraw((i,l)=>{const M=e.map(D=>D.clone());tt(d,i,o,s,M),M.forEach((D,P)=>{var x;const y=(x=e[P])==null?void 0:x.getMcDbEntity();if(y){const g=y.trueColor.getColorValue(y.layerId);l.setColor(Number(g))}l.drawMcDbEntity(D)})});let a=await r.go();if(r.getStatus()===R.kNone)return await c(d);if(!a)return;const n=e.map(i=>i.getMcDbEntity()).filter(i=>!!i);tt(d,a,o,s,n)}_("_stretch",_n);class Nn{constructor(e){G(this,"resizeObserver",null);G(this,"mutationObserver",null);G(this,"element",null);this.callback=e}addListener(e){this.element=e,this.setupResizeObserver(),this.setupMutationObserver()}removeListener(){this.resizeObserver&&(this.resizeObserver.unobserve(this.element),this.resizeObserver.disconnect(),this.resizeObserver=null),this.mutationObserver&&(this.mutationObserver.disconnect(),this.mutationObserver=null),this.element=null}setupResizeObserver(){typeof ResizeObserver<"u"&&(this.resizeObserver=new ResizeObserver(this.callback),this.resizeObserver.observe(this.element))}setupMutationObserver(){typeof MutationObserver<"u"&&(this.mutationObserver=new MutationObserver(this.callback),this.mutationObserver.observe(this.element,{attributes:!0}))}}function Wn(t,e){const o=new Nn(e);return o.addListener(t),o}function $n(t){t.removeListener()}function Kn(t,e){let o;return function(...s){clearTimeout(o),o=setTimeout(()=>t(...s),e)}}function zn(t,e,o){typeof e=="string"&&(e=parseFloat(e));const s=document.createElement("canvas"),r=s.getContext("2d");if(!r)return;r.font=e+"px "+o;let c=r.measureText(t).width,n=e*1.2;return s.remove(),c=Math.ceil(c),n=Math.ceil(n),{width:c,height:n}}function On(t){const e=document.createElement("template");e.innerHTML=t.trim();const o=document.createElement("div");o.style.position="absolute",o.style.visibility="hidden",o.style.pointerEvents="none",o.appendChild(e.content.cloneNode(!0)),document.body.appendChild(o);let{width:s,height:r}=o.getBoundingClientRect();return s=Math.ceil(s)+5,r=Math.ceil(r),document.body.removeChild(o),{width:s,height:r}}function Fn(t){let e={watermark_txt:u("水印"),watermark_html:"",watermark_x:20,watermark_y:20,watermark_rows:200,watermark_cols:200,watermark_x_space:80,watermark_y_space:80,watermark_color:"#aaa",watermark_alpha:.4,watermark_fontsize:"15px",watermark_font:"微软雅黑",watermark_width:"auto",watermark_height:"auto",watermark_angle:15,watermark_className:"mx_mask_div"};e={...e,...t};const o=$.getCurrentMxCAD().mxdraw.getCanvas();let s=null,r=null,d;const c=()=>{document.querySelectorAll("."+e.watermark_className).forEach(l=>l.remove())},a=()=>{c(),d&&$n(d)},n=()=>{const i=document.createDocumentFragment(),l=o.parentElement,M=l.clientWidth,D=l.clientHeight;if(M===s&&D===r)return;s=M,r=D,c();const P=Math.max(l.scrollWidth,l.clientWidth),y=Math.max(l.scrollHeight,l.clientHeight);if(e.watermark_width==="auto"||e.watermark_height==="auto")if(e.watermark_html!==""){const{width:h,height:w}=On(e.watermark_html);e.watermark_width==="auto"&&(e.watermark_width=h),e.watermark_height==="auto"&&(e.watermark_height=w)}else{const h=e.watermark_txt.length,w=parseFloat(e.watermark_fontsize)||16,{width:m=h*w,height:p=w+e.watermark_x_space+e.watermark_y_space}=zn(e.watermark_txt,e.watermark_fontsize,e.watermark_font)||{};e.watermark_width==="auto"&&(e.watermark_width=m),e.watermark_height==="auto"&&(e.watermark_height=p)}e.watermark_cols=Math.ceil(P/(e.watermark_x_space+e.watermark_width)),e.watermark_rows=Math.ceil(y/(e.watermark_y_space+e.watermark_height));let x,g;for(let h=0;h<e.watermark_rows;h++){g=e.watermark_y+(e.watermark_y_space+e.watermark_height)*h;for(let w=0;w<e.watermark_cols;w++){x=e.watermark_x+(e.watermark_width+e.watermark_x_space)*w;var f=document.createElement("div");f.id=(e.watermark_className||"")+h+w,f.className=e.watermark_className||"",e.watermark_html!==""?f.innerHTML=e.watermark_html:f.appendChild(document.createTextNode(e.watermark_txt)),f.style.webkitTransform="rotate(-"+e.watermark_angle+"deg)",f.style.MozTransform="rotate(-"+e.watermark_angle+"deg)",f.style.msTransform="rotate(-"+e.watermark_angle+"deg)",f.style.OTransform="rotate(-"+e.watermark_angle+"deg)",f.style.transform="rotate(-"+e.watermark_angle+"deg)",f.style.visibility="",f.style.position="absolute",f.style.left=x+"px",f.style.top=g+"px",f.style.overflow="hidden",f.style.zIndex="1050",f.style.pointerEvents="none",f.style.opacity=e.watermark_alpha.toString(),f.style.fontSize=e.watermark_fontsize,f.style.fontFamily=e.watermark_font,f.style.color=e.watermark_color,f.style.textAlign="center",f.style.width=e.watermark_width+"px",f.style.height=e.watermark_height+"px",f.style.display="block",i.appendChild(f)}}l.appendChild(i)};return n(),d=Wn(o,Kn(n,200)),a}_("_watermark",Fn);async function Bn(){const t=$.getCurrentMxCAD();for(;;){const e=new Q;e.setMessage(u("选择圆弧或者圆"));const o=await e.go();if(e.getStatus()===R.kCancel||e.getStatus()===R.kNone)return;const s=o.getMcDbEntity();if(s instanceof ee||s instanceof J){const r=new j;r.setMessage(u("指定对角点"));const d=await r.go();if(r.getStatus()===R.kCancel||r.getStatus()===R.kNone)return;if(d){const c=s.center.clone(),a=d.sub(c).normalize().mult(s.radius),n=c.clone().addvec(a),i=c.clone().addvec(a.clone().negate()),l=Math.min(i.distanceTo(d),n.distanceTo(d));t.drawDimDiametric(n.x,n.y,i.x,i.y,l)}break}else{I.acutPrintf(u("所选对象不是圆弧或圆"));continue}}}_("_DrawDiametricDimension",Bn);async function Un(){const t=$.getCurrentMxCAD();for(;;){const e=new Q;e.setMessage(u("选择圆弧或者圆"));const o=await e.go();if(e.getStatus()===R.kCancel||e.getStatus()===R.kNone)return;const s=o.getMcDbEntity();if(s instanceof ee||s instanceof J){const r=s.center.clone(),d=Z.kXAxis.clone().mult(s.radius),c=r.clone().addvec(d);t.drawDimDiametric(r.x,r.y,c.x,c.y,s.radius);break}else{I.acutPrintf(u("所选对象不是圆弧或圆"));continue}}}_("_DrawRadialDimension",Un);function Tt(t){return new Promise(e=>{const{hideLoading:o,showLoading:s}=Pt();try{let r=ke().info(u("正在打开图纸，请耐心等待")+"...");const d=$.App.getCurrentMxCAD().openWebFile(t,c=>{c===0?(ke().success(u("打开图纸成功")),e(!0)):(ke().error(u("打开图纸失败")),e(!1)),o(),r()});pt(t).then(c=>{c/(1024*1024)>1&&d&&s()}),e(d)}catch{o(),e(!1)}})}function Hn(t){Tt(t)}_("_openMxweb",Hn);I.on("mxcadApplicationCreatedMxCADObject",()=>{let t;const e=[],o=$.getCurrentMxCAD().mxdraw.getOrbitControls();o.addEventListener("change",()=>{clearTimeout(t),t=setTimeout(function(){const r=o.object.position.clone(),d=o.object.zoom,c=o.target.clone(),a=$.getCurrentMxCAD().mxdraw.getCamera();e.push({zoom:d,position:r,target:c,camera:a.clone(!1)})},500)});const s=r=>{if(!r)return!1;const d=$.getCurrentMxCAD().mxdraw,c=d.getOrbitControls(),a=c.object.position.clone(),n=c.object.zoom,i=c.target.clone(),l=$.getCurrentMxCAD().mxdraw.getCamera();return l.copy(r.camera,!1),l.updateProjectionMatrix(),n===r.zoom&&a.equals(r.position)&&i.equals(r.target)?s(e.pop()):(c.object.position.copy(r.position),c.object.zoom=r.zoom,c.target.copy(r.target),c.update(),d._mxdrawObj.mcObject.updateDisplayMatrixData(),!0)};_("Mx_WindowZoom",async()=>{let r=new j;r.setMessage(`
`+u("点取缩放区域")),r.setKeyWords(`[${u("全部")}(A)/${u("范围")}(E)/${u("上一个")}(P)/${u("对象")}(O)]`);let d=$.getCurrentMxCAD(),c=await r.go();if(r.isKeyWordPicked("A"))return d.mxdraw.zoomInitialStates();if(r.isKeyWordPicked("E"))return d.zoomAll(!0);if(r.isKeyWordPicked("P")){s(e.pop())||I.acutPrintf(`
`+u("没有保存的上一个视图")+`
`+u("命令"));return}if(r.isKeyWordPicked("O")){const n=await B.userSelect(`ZOOM ${u("选择对象")}`);if(n.length<=0)return;const i=B.getMcDbEntitysBoundingBox(n);if(!i)return;const{minPt:l,maxPt:M}=i;return d.zoomW(l,M)}if(c==null)return;r.setUserDraw((n,i)=>{i.drawRect(lt.cad2doc1(c),lt.cad2doc1(n))}),r.setKeyWords("");let a=await r.go();a!=null&&d.zoomW(c,a)})});class Ee extends fe{constructor(){super(...arguments);G(this,"dDashArray",.03);G(this,"dDashRatio",.1);G(this,"isAligned",!1);G(this,"fixedSize",!0);G(this,"referenceAxis",new THREE.Vector3(0,1,1));G(this,"offsetHeight");G(this,"isDrawsMallRound",!0)}getTypeName(){return"MxAuxiliaryLine"}create(){return new Ee}onViewChange(){return this.fixedSize?(this.setNeedUpdateDisplay(!1),!0):!1}worldDraw(o){const{dDashArray:s,dDashRatio:r}=this.getDash();let d=o.getMxObject();o.setLineWidth(.7),o.setDash(s,r);let c=this.toSmallcoord(d,this.pt1),a=this.toSmallcoord(d,this.pt2),n=c,i=a;typeof this.offsetHeight>"u"&&(this.offsetHeight=d.screenCoordLong2World(40));const l=this.offsetHeight;if(this.isAligned){c.x>a.x&&(c=this.pt2,a=this.pt1);const P=a.clone().sub(c).cross(this.referenceAxis.clone().normalize()).normalize();n=c.clone().add(P.clone().multiplyScalar(l)),i=a.clone().add(P.clone().multiplyScalar(l))}else{const P=Math.abs(this.referenceAxis.y?c.y-a.y:c.x-a.x)+l;let y=l,x=P;(this.referenceAxis.x!==0&&c.x>a.x||this.referenceAxis.y!==0&&c.y>a.y)&&(c=this.pt2,a=this.pt1),this.referenceAxis.x>0&&(y=P,x=l),this.referenceAxis.y>0&&(y=P,x=l),n=c.clone().add(this.referenceAxis.clone().multiplyScalar(y)),i=a.clone().add(this.referenceAxis.clone().multiplyScalar(x))}n.setZ(c.z),i.setZ(a.z);const M=Ve.createDashedLines([c,n,i,a],8421504,.1,.1);if(o.drawEntity(M),this.isDrawsMallRound){const P=d.screenCoordLong2World(1);o.drawCircle(c,P),o.drawCircle(a,P),o.drawCircle(n,P),o.drawCircle(i,P)}const D=n.distanceTo(i).toFixed(3);if(o.getType()===At.kWorldDraw){const P=new Mt;P.opacity=1,P.text=D,P.backgroundColor=16777185,P.color=16,P.position=new THREE.Vector3((n.x+i.x)/2,(n.y+i.y)/2),P.setFontSize(36),P.height=d.screenCoordLong2World(16),P.setLineWidthByPixels(!0),P.setUseSmallcoordDisplay(this.use_smallcoord_display),P.worldDraw(o)}else{const P=Ve.creatTextSprite(D,new THREE.Vector3((n.x+i.x)/2,(n.y+i.y)/2),d.screenCoordLong2World(16),0,16777215);P&&o.drawEntity(P)}}getGripPoints(){return[this.pt1,this.pt2]}moveGripPointsAt(o,s){return o===0&&this.pt1.add(s),o===1&&this.pt2.add(s),!0}dwgIn(o){return super.dwgIn(o),this.dwgInHelp(o,["referenceAxis","isAligned","offsetHeight","fixedSize","isDrawsMallRound"]),!0}dwgOut(o){return o=super.dwgOut(o),this.dwgOutHelp(o,["referenceAxis","isAligned","offsetHeight","fixedSize","isDrawsMallRound"]),o}}class xe extends Yt{constructor(){super(...arguments);G(this,"dDashArray",.03);G(this,"dDashRatio",.1);G(this,"pt1");G(this,"pt2");G(this,"center");G(this,"fixedSize",!0);G(this,"offsetDist");G(this,"isClockwise","auto");G(this,"isDrawsMallRound",!0);G(this,"isMaxRadius",!1);G(this,"radius")}getTypeName(){return"MxAuxiliaryArc"}create(){return new xe}onViewChange(){return this.fixedSize?(this.setNeedUpdateDisplay(!1),!0):!1}calculateLineAngle(o,s,r){const d=Math.PI*2/360;let c=Math.atan2(s.y-o.y,s.x-o.x)*180/Math.PI*d,a=Math.atan2(r.y-o.y,r.x-o.x)*180/Math.PI*d;return{startAngle:c,endAngle:a}}getClockwise(){const o=this.getStartPoint(),s=this.getEndPoint();let r=this.isClockwise;if(r==="auto"){const d=o.clone().sub(this.center),c=s.clone().sub(this.center);r=d.x*c.y-d.y*c.x<0}return r}getAngle(){const o=this.center,s=this.getStartPoint(),r=this.getEndPoint();let d=this.getClockwise();const{startAngle:c,endAngle:a}=this.calculateLineAngle(o,s,r);let n=a-c;return!d&&n<0?n+=2*Math.PI:d&&n>0&&(n-=2*Math.PI),Math.abs(n)}getRadius(o=!1){return this.radius?this.radius+(o&&this.offsetDist||0):this.isMaxRadius?Math.max(this.center.distanceTo(this.pt1),this.center.distanceTo(this.pt2)):this.center.distanceTo(this.pt2)+(o&&this.offsetDist||0)}getStartPoint(o=I.getCurrentDraw()){let s=this.pt1;this.pt2;let r=this.center,d=s;typeof this.offsetDist>"u"&&(this.offsetDist=o.screenCoordLong2World(40));const c=this.offsetDist,a=s.clone().sub(r).normalize(),n=this.getRadius()+c;return d=r.clone().add(a.multiplyScalar(n)),d.setZ(s.z),d}getEndPoint(o=I.getCurrentDraw()){let s=this.pt2,r=this.center,d=s;typeof this.offsetDist>"u"&&(this.offsetDist=o.screenCoordLong2World(40));const c=this.offsetDist,a=s.clone().sub(r).normalize(),n=this.getRadius()+c;return d=r.clone().add(a.multiplyScalar(n)),d.setZ(s.z),d}worldDraw(o){const{dDashArray:s,dDashRatio:r}=this.getDash();let d=o.getMxObject();o.setDash(s,r),o.setLineWidth(.7),this.toSmallcoord(d,this.pt2);let c=this.center;typeof this.offsetDist>"u"&&(this.offsetDist=d.screenCoordLong2World(40));const a=this.offsetDist,n=this.getStartPoint(),i=this.getEndPoint(),l=this.getRadius()+a,{startAngle:M,endAngle:D}=this.calculateLineAngle(c,n,i);let P=this.getClockwise();const y=new THREE.ArcCurve(c.x,c.y,l,M,D,P),x=new THREE.Geometry().setFromPoints(y.getPoints(50)),g=Ve.createDashedLines([n,c,i],8421504,.1,.1);if(o.setColor(8421504),o.drawEntity(g),o.drawGeometryLines(x),this.isDrawsMallRound){const A=d.screenCoordLong2World(2);o.drawCircle(n,A),o.drawCircle(i,A)}const f=this.getAngle(),h=THREE.MathUtils.radToDeg(f).toFixed(3)+"°",{x:w,y:m}=y.getPointAt(.5),p=new THREE.Vector3(w,m);if(o.getType()===At.kWorldDraw){const A=new Mt;A.opacity=1,A.text=h,A.backgroundColor=16777185,A.color=16,A.position=p,A.setFontSize(36),A.height=d.screenCoordLong2World(16),A.setLineWidthByPixels(!0),A.setUseSmallcoordDisplay(this.use_smallcoord_display),A.worldDraw(o)}else{const A=Ve.creatTextSprite(h,p,d.screenCoordLong2World(16),0,16777215);A&&o.drawEntity(A)}}getGripPoints(){return[this.pt1,this.pt2,this.center]}moveGripPointsAt(o,s){return o===0&&this.pt1.add(s),o===1&&this.pt2.add(s),o===2&&this.center.add(s),!0}dwgIn(o){return this.dwgInHelp(o,["fixedSize","isDrawsMallRound","offsetDist","pt1","pt2","center","isClockwise","isMaxRadius","radius"]),!0}dwgOut(o){return this.dwgOutHelp(o,["fixedSize","isDrawsMallRound","offsetDist","pt1","pt2","center","isClockwise","isMaxRadius","radius"]),o}}function Ke(t,e,o){if(t.isEqualTo(e))return 0;let s=t.c().addvec(e.c().sub(t).mult(.5)),r=e.c().sub(t);r.rotateBy(Math.PI/2,Z.kZAxis);let d=new H(s,s.c().addvec(r)),c=o.c();c.rotateBy(Math.PI/2,Z.kZAxis);let a=new H(t,t.c().addvec(c)),n=d.IntersectWith(a,Re.Intersect.kExtendBoth);if(n.isEmpty())return 0;let i=n.at(0),l=i.distanceTo(t);r.normalize(),r.mult(l);let M=i.c().addvec(r),D=i.c().subvec(r),P=M.c().sub(t),y=D.c().sub(t),x=M;return P.angleTo1(o)>y.angleTo1(o)&&(x=D),B.calcBulge(t,x,e).val}const Rt=async(t,e)=>{var P;let o=!0;const s=new j;let r=!1;const d=y=>{y.key==="Control"&&(r=!0)},c=$.getCurrentMxCAD(),a=()=>r=!1;window.addEventListener("keydown",d),window.addEventListener("keyup",a);const n=()=>{window.removeEventListener("keydown",d),window.removeEventListener("keyup",a)};if(!t){s.clearLastInputPoint(),s.setMessage(u("指定第一点"));const y=await s.go();if(s.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!y)return n();t=y}const i=[{point:t}];for(;;)if(o){s.setMessage(u("指定下一个点")),s.setKeyWords(`[${u("圆弧")}(A)/${i.length>2?u("闭合")+"(C)/":""}${u("放弃")}(U)/${u("总计")}(T)]`),s.setUserDraw((x,g)=>{const f=new W;i.forEach(({point:h,bulge:w})=>{f.addVertexAt(h,w)}),f.addVertexAt(x),g.drawMcDbEntity(f)});const y=await s.go();if(s.getDetailedResult()===T.kNullEnterIn||s.getDetailedResult()===T.kNullSpaceIn){const x=new W;i.forEach(({point:h,bulge:w})=>{x.addVertexAt(h,w)});const g=x.getLength().val,f=c.drawEntity(x);return e&&e(i),{dist:g,pl:x,plId:f}}if(s.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(s.getStatus()===R.kCancel||s.getStatus()===R.kNone)return n();if(s.isKeyWordPicked("A")){o=!1;continue}else if(s.isKeyWordPicked("U")){i.length===0?I.acutPrintf(u("已放弃所有线段")):(i.pop(),(P=i[i.length-1])!=null&&P.point&&s.setLastInputPoint(i[i.length-1].point),e&&e(i));continue}else if(s.isKeyWordPicked("T")){const x=new W;i.forEach(({point:h,bulge:w})=>{x.addVertexAt(h,w)});const g=x.getLength().val,f=c.drawEntity(x);return e&&e(i),{dist:g,pl:x,plId:f}}else if(s.isKeyWordPicked("C")){const x=new W;x.isClosed=!0,i.forEach(({point:h,bulge:w})=>{x.addVertexAt(h,w)});const g=x.getLength().val;e&&e(i);const f=c.drawEntity(x);return{dist:g,pl:x,plId:f}}else if(y){i.push({point:y}),e&&e(i);continue}}else{const y=s;y.setMessage(he("NO1_ID_ARX_PL5",`${u("指定圆弧的端点")}(${u("按住 Ctrl 键以切换方向")})`)),y.setKeyWords(`[${u("角度")}(A)/${u("圆心")}(CE)/${i.length>2?u("闭合")+"(C)/":""}${u("方向")}(D)/${u("直线")}(L)/${u("半径")}(R)/${u("第二个点")}(S)/${u("放弃")}(U)]`);let x=new Z;if(i.length<2)x.copy(Z.kXAxis);else{let h=i.length,w=i[h-2].point,m=i[h-2].bulge,p=i[h-1].point;if(!m||Math.abs(m)<1e-7)x=new z(p.x,p.y,0).sub(new z(w.x,w.y,0));else{let A=new W;A.addVertexAt(w,m),A.addVertexAt(p);let b=A.getFirstDeriv(new z(p.x,p.y,0));b.ret?x=b.val:x.copy(Z.kXAxis)}}let g=i[i.length-1];y.setUserDraw((h,w)=>{let m=Ke(g.point,h,r?x.clone().negate():x),p=new W;i.forEach(({point:A,bulge:b})=>{p.addVertexAt(A,b)}),p.addVertexAt(g.point,m),p.addVertexAt(h),w.drawMcDbEntity(p)});let f=await y.go();if(y.getDetailedResult()===T.kNullEnterIn||y.getDetailedResult()===T.kNullSpaceIn){const h=new W;i.forEach(({point:p,bulge:A})=>{h.addVertexAt(p,A)});const w=h.getLength().val,m=c.drawEntity(h);return e&&e(i),{dist:w,pl:h,plId:m}}if(f!==null){let h={point:f,bulge:0};i[i.length-1].bulge=Ke(g.point,h.point,r?x.clone().negate():x),i.push(h),e&&e(i)}else if(y.getStatus()==R.kKeyWord){if(y.isKeyWordPicked("A")){const h=new le;h.setBasePt(g.point),h.setMessage(he("ID_ARX_PLGET_I_ANGLE",u("指定夹角")));const w=await h.go();if(h.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(w===null)break;y.setMessage(`${u("指定圆弧的端点")}(${u("按住 Ctrl 键以切换方向")})`),y.setKeyWords(`[${u("圆心")}(CE)/${u("半径")}(R)]`),y.setLastInputPoint(g.point);const m=i[i.length-1].point,p=C=>{const k=Math.PI/2-w/2,E=new z((C.x+m.x)/2,(C.y+m.y)/2),S=E.distanceTo(m),v=S/Math.sin(k),L=S/Math.tan(k),V=E.sub(m).rotateBy(Math.PI/2).normalize().mult(r?-v-L:v-L),K=E.addvec(V);return B.calcBulge(m,K,C).val};y.setUserDraw((C,k)=>{const E=p(C);let S=new W;i.forEach(({point:v,bulge:L})=>{S.addVertexAt(v,L)}),S.addVertexAt(g.point,E),S.addVertexAt(C),k.drawMcDbEntity(S)});const A=await y.go();if(y.isKeyWordPicked("CE")){y.setMessage(u("指定圆弧的圆心")),y.setKeyWords(""),y.setBasePt(m),y.setUserDraw((v,L)=>{const V=v.distanceTo(m),K=v.addvec(v.sub(m).rotateBy(w).normalize().mult(V)),F=p(K);let N=new W;i.forEach(({point:U,bulge:X})=>{N.addVertexAt(U,X)}),N.addVertexAt(g.point,F),N.addVertexAt(K),L.drawMcDbEntity(N)});const C=await y.go();if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!C)break;const k=C.distanceTo(m),E=C.addvec(C.sub(m).rotateBy(w).normalize().mult(k));let S={};S.bulge=0,S.point=E,i[i.length-1].bulge=p(E),i.push(S),y.setLastInputPoint(E),e&&e(i);continue}if(y.isKeyWordPicked("R")){const C=new Pe;C.setMessage(u("指定圆弧半径")),C.setKeyWords("");const k=await C.go();if(C.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(typeof k!="number")break;const E=k*Math.sin(w/2);y.setBasePt(m),y.setMessage(`${u("指定圆弧的弦方向")}(${u("按住 Ctrl 键切换方向")})`),y.setKeyWords(""),y.setUserDraw((V,K)=>{const F=m.clone().addvec(V.sub(m).normalize().mult(E*2)),N=p(F);let U=new W;i.forEach(({point:X,bulge:q})=>{U.addVertexAt(X,q)}),U.addVertexAt(g.point,N),U.addVertexAt(F),K.drawMcDbEntity(U)});const S=await y.go();if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!S)break;const v=m.clone().addvec(S.sub(m).normalize().mult(E*2));let L={};L.bulge=0,L.point=v,i[i.length-1].bulge=p(v),i.push(L),e&&e(i);continue}if(!A)break;let b={};b.bulge=0,b.point=A,i[i.length-1].bulge=p(A),i.push(b),e&&e(i)}if(y.isKeyWordPicked("CE")){y.setMessage(u("指定圆弧的圆心")),y.setKeyWords(""),y.setUserDraw(()=>{});const h=await y.go();if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!h)return n();const w=g.point,m=h.distanceTo(w);y.setLastInputPoint(w),y.setMessage(`${u("指定圆弧的端点")}(${u("按住 Ctrl 键以切换方向")})`),y.setKeyWords(`[${u("角度")}(A)/${u("长度")}(L)]`),y.clearLastInputPoint(),y.setUserDraw((L,V)=>{V.drawLine(L.toVector3(),h.toVector3());const K=h.clone().addvec(L.sub(h).normalize().mult(m)),F=h.sub(w).angleTo2(h.sub(K),Z.kZAxis),N=new z((w.x+K.x)/2,(w.y+K.y)/2),U=h.sub(N).normalize().mult(-m),X=h.clone().addvec((r?F<Math.PI:F>Math.PI)?U.negate():U),q=B.calcBulge(w,X,K).val;let Y=new W;i.forEach(({point:ge,bulge:de})=>{Y.addVertexAt(ge,de)}),Y.addVertexAt(g.point,q),Y.addVertexAt(K),V.drawMcDbEntity(Y)});const p=await y.go();if(y.isKeyWordPicked("A")){const L=new le;L.setBasePt(h),L.setMessage(he("ID_ARX_PLGET_I_ANGLE",`${u("指定夹角")}(${u("按住 Ctrl 键以切换方向")})`)),L.setKeyWords(""),L.setUserDraw((ge,de)=>{const ie=Z.kXAxis.clone().angleTo2(ge.sub(h),Z.kZAxis),oe=r?Math.PI*2-ie/2:ie/2,ce=w.sub(h).rotateBy(oe).normalize().mult(m),ye=w.sub(h).rotateBy(ie).normalize().mult(m),we=h.clone().addvec(ce),te=h.clone().addvec(ye),Me=B.calcBulge(w,we,te).val;let ne=new W;i.forEach(({point:De,bulge:rt})=>{ne.addVertexAt(De,rt)}),ne.addVertexAt(g.point,Me),ne.addVertexAt(te),de.drawMcDbEntity(ne)});const V=await L.go();if(L.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(V===null)break;const K=r?Math.PI*2-V/2:V/2,F=w.sub(h).rotateBy(K).normalize().mult(m),N=w.sub(h).rotateBy(V).normalize().mult(m),U=h.clone().addvec(F),X=h.clone().addvec(N),q=B.calcBulge(w,U,X).val;let Y={};Y.bulge=0,Y.point=X,i[i.length-1].bulge=q,i.push(Y),new W,e&&e(i);continue}if(y.isKeyWordPicked("L")){const L=new Pe;L.setMessage(`${u("指定弦长")}(${u("按住 Ctrl 键以切换方向")})`),L.setKeyWords(""),L.setBasePt(w),L.setUserDraw((Y,ge)=>{const de=Y.distanceTo(w);if(de>m*2)return;const ie=Math.asin(de/2/m)*2,oe=w.sub(h).normalize().mult(m),ce=h.clone().addvec(oe.clone().rotateBy(r?Math.PI-ie/2:ie/2)),ye=h.clone().addvec(oe.clone().rotateBy(ie)),we=B.calcBulge(w,ce,ye).val;let te=new W;i.forEach(({point:Me,bulge:ne})=>{te.addVertexAt(Me,ne)}),te.addVertexAt(g.point,we),te.addVertexAt(ye),ge.drawMcDbEntity(te)});const V=await L.go();if(L.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(typeof V!="number")break;if(V>m*2){I.acutPrintf(`*${u("弦长不能大于直径")} ${u("无效")}*`),y.setLastInputPoint(w);continue}const K=Math.asin(V/2/m)*2,F=w.sub(h).normalize().mult(m),N=h.clone().addvec(F.clone().rotateBy(r?Math.PI-K/2:K/2)),U=h.clone().addvec(F.clone().rotateBy(K)),X=B.calcBulge(w,N,U).val;let q={};q.bulge=0,q.point=U,i[i.length-1].bulge=X,i.push(q),y.setLastInputPoint(U),e&&e(i);continue}if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!p)return n();const A=h.clone().addvec(p.sub(h).normalize().mult(m)),b=h.sub(w).angleTo2(h.sub(A),Z.kZAxis),C=new z((w.x+A.x)/2,(w.y+A.y)/2),k=h.sub(C).normalize().mult(-m),E=h.clone().addvec((r?b<Math.PI:b>Math.PI)?k.negate():k),S=B.calcBulge(w,E,A).val;let v={};v.bulge=0,v.point=A,i[i.length-1].bulge=S,i.push(v),y.setLastInputPoint(A),e&&e(i);continue}if(y.isKeyWordPicked("R")){let h=new Pe;h.setMessage(he("ID_ARX_PLGETSTARTRADIUS",u("指定圆弧的半径"))),h.setKeyWords("");let w=await h.go();if(h.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(w===null)break;const m=g.point;y.setLastInputPoint(m),y.setMessage(`${u("指定圆弧的端点")}(${u("按住 Ctrl 键以切换方向")})`),y.setKeyWords(`[${u("角度")}(A)]`),y.setUserDraw((v,L)=>{if(!w)return;const V=v.distanceTo(m);if(V>w*2)return;const K=Math.acos(V/2/w),F=m.clone().addvec(v.sub(m).rotateBy(K).normalize().mult(w)),N=F.clone().addvec(new z((m.x+v.x)/2,(m.y+v.y)/2).sub(F).normalize().mult(r?-w:w)),U=B.calcBulge(m,N,v).val;let X=new W;i.forEach(({point:q,bulge:Y})=>{X.addVertexAt(q,Y)}),X.addVertexAt(g.point,U),X.addVertexAt(v),L.drawMcDbEntity(X)});const p=await y.go();if(y.isKeyWordPicked("A")){const v=new le;v.setMessage(he("ID_ARX_PLGET_I_ANGLE",u("指定夹角"))),v.setKeyWords(""),v.setBasePt(m);const L=await v.go();if(v.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(typeof L!="number")break;const V=Math.sin(L/2)*w*2;y.setMessage(`${u("指定圆弧的弦方向")}(${u("按住 Ctrl 键以切换方向")})`),y.setKeyWords(""),y.setBasePt(m),y.setUserDraw((ge,de)=>{if(!w)return;const ie=ge.sub(m).normalize(),oe=m.clone().addvec(ie.clone().mult(V)),ce=oe.clone().addvec(ie.clone().negate().rotateBy(-(Math.PI/2-L/2)).mult(w)),ye=ce.clone().addvec(ce.sub(new z((m.x+oe.x)/2,(m.y+oe.y)/2)).normalize().mult(r?w:-w)),we=B.calcBulge(m,ye,oe).val;let te=new W;i.forEach(({point:Me,bulge:ne})=>{te.addVertexAt(Me,ne)}),te.addVertexAt(g.point,we),te.addVertexAt(oe),de.drawMcDbEntity(te)});const K=await y.go();if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!K)break;const F=K.sub(m).normalize(),N=m.clone().addvec(F.clone().mult(V)),U=N.clone().addvec(F.clone().negate().rotateBy(-(Math.PI/2-L/2)).mult(w)),X=U.clone().addvec(U.sub(new z((m.x+N.x)/2,(m.y+N.y)/2)).normalize().mult(r?w:-w)),q=B.calcBulge(m,X,N).val;let Y={};Y.bulge=0,Y.point=N,i[i.length-1].bulge=q,i.push(Y),e&&e(i);continue}if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!p)break;const A=p.distanceTo(m);if(A>w*2){I.acutPrintf(`${u("指定圆弧的端点")} *${u("无效")}*`);continue}const b=Math.acos(A/2/w),C=m.clone().addvec(p.sub(m).rotateBy(b).normalize().mult(w)),k=C.clone().addvec(new z((m.x+p.x)/2,(m.y+p.y)/2).sub(C).normalize().mult(r?-w:w)),E=B.calcBulge(m,k,p).val;let S={};S.bulge=0,S.point=p,i[i.length-1].bulge=E,i.push(S),e&&e(i);continue}if(y.isKeyWordPicked("D")){y.setMessage(u("指定圆弧起点切向")),y.setKeyWords(""),y.setUserDraw((A,b)=>{b.drawLine(A.toVector3(),g.point.toVector3())});const h=await y.go();if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(!h)break;const w=h.sub(g.point);y.setLastInputPoint(g.point),y.setMessage(`${u("指定圆弧的端点")}(${u("按住 Ctrl 键以切换方向")})`),y.setKeyWords(""),y.setUserDraw((A,b)=>{let C=Ke(g.point,A,r?w.clone().negate():w),k=new W;i.forEach(({point:E,bulge:S})=>{k.addVertexAt(E,S)}),k.addVertexAt(g.point,C),k.addVertexAt(A),b.drawMcDbEntity(k)});const m=await y.go();if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;let p={};p.bulge=0,p.point=m,i[i.length-1].bulge=Ke(g.point,p.point,r?w.clone().negate():w),i.push(p),e&&e(i);continue}if(y.isKeyWordPicked("L"))o=!0;else if(y.isKeyWordPicked("S")){let h=new z(i[i.length-1].point.x,i[i.length-1].point.y,0),w=new j;w.setMessage(he("NO1_ID_SPECIFY_ARC2",u("指定圆弧的第二个点"))),w.setBasePt(h);let m=await w.go();if(w.getDetailedResult()===T.kNewCommadIn)return n(),!1;if(m===null)break;let p=new j;p.setMessage(he("ID_CIRCULAR_ENDPOINT",`${u("指定圆弧的端点")}(${u("按住 Ctrl 键以切换方向")})`)),p.setUserDraw((b,C)=>{const k=new ee;k.computeArc(h.x,h.y,m.x,m.y,b.x,b.y);let E=m;r&&(E=k.center.clone().addvec(k.center.clone().sub(m)));let S=B.calcBulge(h,E,b).val;const v=new W;i.forEach(({point:L,bulge:V})=>{v.addVertexAt(L,V)}),v.addVertexAt(g.point,S),v.addVertexAt(b),C.drawMcDbEntity(v)});let A=await p.go();if(A!==null){let b=m;if(r){const k=new ee;k.computeArc(h.x,h.y,m.x,m.y,A.x,A.y),b=k.center.clone().addvec(k.center.clone().sub(m))}let C=B.calcBulge(h,b,A);if(C.ret){let k={};k.point=A,k.dBluge=0,i[i.length-1].bulge=C.val,i.push(k),e&&e(i)}else I.acutPrintf(he("ID_ENDPOINT_INVALID1",`
 ${u("端点")} *${u("无效")}*`))}else{if(p.getDetailedResult()===T.kNewCommadIn)return n(),!1;break}}else if(y.isKeyWordPicked("C")){i[i.length-1].bulge=Ke(g.point,t,r?x.clone().negate():x);const h=new W;h.isClosed=!0,i.forEach(({point:p,bulge:A})=>{h.addVertexAt(p,A)});const w=h.getLength().val;e&&e(i);const m=c.drawEntity(h);return{dist:w,pl:h,plId:m}}else if(y.isKeyWordPicked("U")&&i.length>1){i.pop();const h=new W;i.forEach(({point:w,bulge:m})=>{h.addVertexAt(w,m)}),e&&e(i),i.length>0&&y.setLastInputPoint(i[i.length-1].point)}}else{if(y.getDetailedResult()===T.kNewCommadIn)return n(),!1;break}}const l=new W;i.forEach(({point:y,bulge:x})=>{l.addVertexAt(y,x)});const M=l.getLength().val;e&&e(i);const D=c.drawEntity(l);return{dist:M,pl:l,plId:D}};function ft(t,e){const o=e.x,s=e.y;return t.x>o&&t.y>s||t.x<o&&t.y<s}function jn(t,e){const o=(t.x+e.x)/2,s=(t.y+e.y)/2;return new z(o,s)}function Xn(t,e,o){const s=ft(t,o),r=ft(e,o);return s&&r}async function Vt(t=!1){const e=new j;let o=[];e.clearLastInputPoint(),e.setMessage(u("指定第一点"));const s=await e.go();if(e.getDetailedResult()===T.kNewCommadIn)return!1;if(!s)return;e.setUserDraw((d,c)=>{c.drawLine(s.toVector3(),d.toVector3())}),e.setMessage(u("指定第二点")),e.setKeyWords(`[${u("多个点")}(M)]`);const r=await e.go();if(e.getDetailedResult()===T.kNewCommadIn)return!1;if(e.getStatus()!==R.kCancel){if(e.isKeyWordPicked("M")){const d=await Rt(s,n=>{const i=new W;n.forEach(({point:l,bulge:M})=>{i.addVertexAt(l,M)}),I.acutPrintf(u("距离")+" = "+i.getLength().val)});if(d===!1)return d;const{plId:c}=d||{};if(!c)return;const a=c.getMcDbEntity();return a&&o.push(a),{markedLines:o}}else if(r){if(t){const D=Xn(s,r,jn(s,r)),P=new Ee;if(P.referenceAxis=new THREE.Vector3(0,0,D?-1:1),P.isAligned=!0,P.pt1=s.toVector3(),P.pt2=r.toVector3(),I.addToCurrentSpace(P),o.push(P),Math.abs(s.x-r.x)>.001&&Math.abs(s.y-r.y)>.001){const x=new Ee;x.isAligned=!1,x.referenceAxis=new THREE.Vector3(0,s.y>r.y?1:-1,-1),x.pt1=s.toVector3(),x.pt2=r.toVector3(),I.addToCurrentSpace(x),o.push(x);const g=new Ee;g.isAligned=!1,g.referenceAxis=new THREE.Vector3(s.x>r.x?1:-1,0,-1),g.pt1=s.toVector3(),g.pt2=r.toVector3(),I.addToCurrentSpace(g),o.push(g);const f=new xe;f.offsetDist=0,f.center=s.toVector3(),f.pt1=s.toVector3().add(new THREE.Vector3(1,0,0)),f.pt2=r.toVector3(),I.addToCurrentSpace(f),o.push(f)}const y=new fe;y.pt1=s.toVector3(),y.pt2=r.toVector3(),I.addToCurrentSpace(y),o.push(y)}const d=s.distanceTo(r);let c=r.x-s.x,a=r.y-s.y,n=r.z-s.z,i=Math.atan2(a,c)*(180/Math.PI),l=Math.sqrt(c*c+a*a+n*n),M=l===0?0:Math.asin(n/l)*(180/Math.PI);return I.acutPrintf(`${u("距离")} = ${Le(d,4)} , XY ${u("平面中的倾角")} = ${Le(i,4)} , ${u("与")} XY ${u("平面的夹角")} = ${Le(M,4)}
 X 增量 = ${Le(c,4)}，  Y 增量 = ${Le(a,4)}，   Z 增量 = ${Le(n,4)}`),{dist:d,angleInDegrees:i,angleWithZAxis:M,deltaX:c,deltaY:a,deltaZ:n,markedLines:o}}}}_("_MxMeasurementDistance",Vt);async function Yn(t=!1){for(;;){const e=new Q,o=new ae;o.AddMcDbEntityTypes("CIRCLE,ARC"),e.setFilter(o),e.setMessage(u("选择圆弧或圆"));const s=await e.go();if(e.getDetailedResult()===T.kCodeAbort||e.getDetailedResult()===T.kEcsIn||e.getDetailedResult()===T.kMouseRightIn)return;if(e.getDetailedResult()===T.kNewCommadIn)return!1;if(e.getDetailedResult()===T.kNullSpaceIn||e.getDetailedResult()===T.kNullEnterIn||!s)return;const r=s.getMcDbEntity();if(r instanceof ee||r instanceof J){const d=[];if(t){const{val:c,ret:a}=r.getClosestPointTo(e.getDocPickPoint(),!1);if(!a||!c)return;const n=r.center,i=new Ee;i.pt1=c.toVector3(),i.pt2=n.toVector3(),i.isAligned=!0,i.offsetHeight=0,I.addToCurrentSpace(i),d.push(i)}return I.acutPrintf(u("半径")+" = "+r.radius+`
`+u("直径")+" = "+r.radius*2+`
`),{radius:r.radius,markedLines:d}}}}function qe(t,e,o,s){const r=Ne(s,t,o),d=Ne(s,e,o);return isNaN(d)?!0:isNaN(r)?!1:d===r?o.distanceTo(t)>o.distanceTo(e):r<d}async function Gn(){const t=new Q,e=new ae;for(e.AddMcDbEntityTypes("CIRCLE,ARC,LINE,LWPOLYLINE");;){t.setFilter(e),t.setMessage(`${u("选择")}${u("圆弧")}、${u("圆")}、${u("直线")}<${u("指定顶点")}>`);const o=await t.go(),s=t.getDetailedResult(),r=[];if(t.getDetailedResult()===T.kNewCommadIn||t.getDetailedResult()===T.kCodeAbort)return!1;if(t.getDetailedResult()===T.kEcsIn)return;if(s===T.kNullEnterIn||s===T.kNullSpaceIn||s===T.kMouseRightIn){const c=new Gt,a=new xe;c.setMessage(`
${u("指定角的顶点")}`);const n=await c.go();if(!n)return;a.center=n,c.setMessage("\n${t('指定角的第一个端点')}"),c.setUserDraw((x,g)=>{g.drawLine(x,n)});const i=await c.go();if(!i)return;a.pt1=i,c.setMessage(`
${u("指定角的第二个端点")}:`),c.setUserDraw((x,g)=>{g.drawLine(x,n),g.drawLine(i,n),a.offsetDist=0,a.pt2=x,g.drawCustomEntity(a)});const l=await c.go();if(!l)return;a.pt2=l;let M=n.distanceTo(i)-n.distanceTo(l);a.offsetDist=M<0?0:M/2;const D=new fe;D.pt1=n,D.pt2=i;const P=new fe;P.pt1=n,P.pt2=l,I.addToCurrentSpace(D),I.addToCurrentSpace(P),I.addToCurrentSpace(a);const y=a.getAngle();return I.acutPrintf(u("角度")+" = "+y+"°"),r.push(a,D,P),{angle:y,markedArcs:r}}if(!o)continue;const d=o.getMcDbEntity();if(d){if(d instanceof H||d instanceof W){let c,a,n,i;const l=t.getDocPickPoint();let M;if(d instanceof W){const{start:A,end:b}=We(d,l,2)||{};c=A,a=b}else c=d.startPoint,a=d.endPoint;if(!c||!a)continue;for(;;){const A=new ae;A.AddMcDbEntityTypes("LINE,LWPOLYLINE"),t.setFilter(A),t.setMessage(u("选择第二条直线"));const b=await t.go();if(M=t.getDocPickPoint(),t.getDetailedResult()===T.kNewCommadIn||t.getDetailedResult()===T.kCodeAbort)return!1;if(t.getDetailedResult()===T.kEcsIn)return;if(!b||!b.isValid())continue;let C=b.getMcDbEntity();if(C instanceof W){const{start:k,end:E}=We(C,M,2)||{};n=k,i=E}else C instanceof H&&(n=C.startPoint,i=C.endPoint);if(n&&i)break}const D=new H(c,a).IntersectWith(new H(n,i),Re.Intersect.kExtendBoth);if(D.isEmpty()){I.acutPrintf(u("直线是平行的"));return}if(!c||!a||!n||!i||!M)continue;const P=D.at(0),x=qe(c,a,P,l)?c:a,f=qe(n,i,P,l)?n:i,h=new xe;h.center=P.toVector3(),h.pt1=x.toVector3(),h.pt2=f.toVector3(),h.isMaxRadius=!0,h.offsetDist=0,I.addToCurrentSpace(h);const w=h.getAngle();I.acutPrintf(u("角度")+" = "+w+"°"),r.push(h);const m=new fe;m.pt1=h.pt1,m.pt2=h.center;const p=new fe;return p.pt1=h.center,p.pt2=h.pt2,I.addToCurrentSpace(m),I.addToCurrentSpace(p),r.push(m,p),{angle:w,markedArcs:r}}if(d instanceof ee){const c=new xe;c.offsetDist=d.radius,c.center=d.center.toVector3(),c.pt1=new THREE.Vector3(d.radius),c.pt1.applyAxisAngle(new THREE.Vector3(0,0,1),d.startAngle).add(d.center.toVector3()),c.pt2=new THREE.Vector3(d.radius),c.pt2.applyAxisAngle(new THREE.Vector3(0,0,1),d.endAngle).add(d.center.toVector3());let a=d.endAngle-d.startAngle;a>Math.PI?a-=Math.PI*2:a<-Math.PI&&(a+=Math.PI*2),c.isClockwise=Math.abs(a)>Math.PI&&a>0,I.addToCurrentSpace(c);const n=c.getAngle();I.acutPrintf(u("角度")+" = "+n+"°"),r.push(c);const i=new fe;i.pt1=c.pt1,i.pt2=c.center;const l=new fe;return l.pt1=c.center,l.pt2=c.pt2,I.addToCurrentSpace(i),I.addToCurrentSpace(l),r.push(i,l),{angle:n,markedArcs:r}}if(d instanceof J){const c=new xe;c.center=d.center.toVector3(),c.pt1=t.getDocPickPoint().toVector3();const a=new j;a.setUserDraw((l,M)=>{c.pt2=l.toVector3(),c.offsetDist=0,M.drawCustomEntity(c)}),a.setMessage(u("指定第二个端点"));const n=await a.go();if(a.getDetailedResult()===T.kNewCommadIn)return!1;if(!n)return;c.pt2=n.toVector3(),c.offsetDist=d.radius,I.addToCurrentSpace(c);const i=c.getAngle();return I.acutPrintf(u("角度")+" = "+i+"°"),r.push(c),{angle:i,markedArcs:r}}}}}const _t=t=>{const e=t.numVerts(),o=[];if(e<3)return o;const s=$.getCurrentMxCAD(),r=t.getPointAt(0).val,d=t.getPointAt(e-1).val;if(!t.isClosed&&!r.isEqualTo(d))return o;s.pathMoveTo(r.x,r.y);for(let n=0;n<e;n++){const i=t.getPointAt(n).val,l=t.getBulgeAt(n),{val1:M,val2:D}=t.getWidthsAt(n);s.pathLineToEx(i.x,i.y,M,D,l)}s.pathLineTo(d.x,d.y);const a=s.drawPathToHatch().getMcDbEntity();return a&&o.push(a),o},qn=async t=>{const e=$.getCurrentMxCAD();if(t instanceof W)return _t(t);if(t instanceof J){e.pathMoveTo(t.center.x,t.center.y),e.pathCircle(t.center.x,t.center.y,t.radius);const s=e.drawPathToHatch().getMcDbEntity();if(s)return[s]}else{const o=t.clone(),{minPt:s,maxPt:r}=e.getDatabase().currentSpace.getBoundingBox(),d=s.clone(),c=r.clone();o.move(d,c);const a=o.getBoundingBox(),n=new z((a.minPt.x+a.maxPt.x)/2,(a.minPt.y+a.maxPt.y)/2),i=e.drawEntity(o);await(async()=>new Promise(M=>setTimeout(M,1)))();const l=B.builderHatchFromPoint(n);if(i.erase(),o.erase(),l){l.move(c,d);const D=e.drawEntity(l).getMcDbEntity();if(D)return[D]}}},Zn=async()=>{const t=new j;let e=[],o=!1,s=!1,r=0;for(;;){t.setMessage((o?`(${u("加模式")})`:"")+(s?`(${u("减模式")})`:"")+`${u("指定第一个角点")}<${u("对象")}>`),t.setKeyWords(`[${u("对象")}(O)/${o?"":u("增加面积")+"(A)/"}${s?"":u("减少面积")+"(S)/"}${u("退出")}(X)]`),await(async()=>new Promise(c=>setTimeout(c,1)))();const d=await t.go();if(t.getDetailedResult()===T.kNewCommadIn)return e.length>0?{markedLines:e}:!1;if(t.getDetailedResult()===T.kCodeAbort)return e.length>0?{markedLines:e}:!1;if(t.getDetailedResult()===T.kEcsIn||t.getDetailedResult()===T.kMouseRightIn)return e.length>0?{markedLines:e}:void 0;if(t.isKeyWordPicked("O")||t.getDetailedResult()===T.kNullEnterIn||t.getDetailedResult()===T.kNullSpaceIn)for(;;){const c=new Q;c.setMessage(u("选择对象")),await(async()=>new Promise(D=>setTimeout(D,1)))();const a=await c.go();if(c.getDetailedResult()===T.kNewCommadIn)return e.length>0?{markedLines:e}:!1;if(c.getDetailedResult()===T.kCodeAbort)return e.length>0?{markedLines:e}:!1;if(c.getDetailedResult()===T.kEcsIn)return e.length>0?{markedLines:e}:!1;if(c.getDetailedResult()===T.kNullEnterIn||c.getDetailedResult()===T.kNullSpaceIn||c.getDetailedResult()===T.kMouseRightIn)break;if(!a)continue;const n=a.getMcDbEntity();if(!n)continue;let i=n.getArea().val,l=0;n instanceof Te&&(l=n.getLength().val);const M=await qn(n);if(M&&e.push(...M),i===0&&M)if(n instanceof J)i=Math.PI*Math.pow(n.radius,2);else if(n instanceof _e&&n.startAngle===0&&n.endAngle===Math.PI*2){const D=Math.sqrt(n.majorAxis.x*n.majorAxis.x+n.majorAxis.y*n.majorAxis.y)/2,P=D*n.radiusRatio;i=Math.PI*D*P;const y=Math.pow((D-P)/(D+P),2);l=Math.PI*(D+P)*(1+3*y/(10+Math.sqrt(4-3*y)))}else i=M.reduce((D,P)=>D+P.getArea().val,0);if(i===0?I.acutPrintf(u("选定的对象没有面积")+`
`):I.acutPrintf(`${u("区域")} = ${i}, ${u("周长")} = ${l}
`),o||s){o?r+=i:r-=i,I.acutPrintf(`${u("总面积")} = ${r}
`);continue}return{markedLines:e}}if(t.isKeyWordPicked("A")){o=!0,s=!1;continue}if(t.isKeyWordPicked("S")){s=!0,o=!1;continue}if(t.isKeyWordPicked("X"))return I.acutPrintf(`${u("总面积")} = ${r}
`),e.length>0?{markedLines:e}:void 0;if(d){const c=await Rt(d);if(c===!1)return e.length>0?{markedLines:e}:c;const{plId:a}=c||{};if(!a)return e.length>0?{markedLines:e}:void 0;const n=a.getMcDbEntity();if(n instanceof W){n.isClosed=!0,e.push(n);const i=_t(n);e.push(...i);const l=n.getArea().val;if(I.acutPrintf(`${u("区域")} = ${n.getArea().val}, ${u("周长")} = ${n.getLength().val}
`),o||s){o?r+=l:r-=l,I.acutPrintf(`${u("总面积")} = ${r}
`);continue}return{markedLines:e}}}}};class Jn extends fe{getTypeName(){return"MxSelectLine"}worldDraw(e){e.setLineWidthByPixels(!0),e.setLineWidth(10),e.setColor(16737894),e.drawSelectLine(this.pt1,this.pt2)}}function Nt(t,e,o){const r=t.distanceTo(e)/2,d=r*o,c=(r*r+d*d)/(2*d),a=(t.x+e.x)/2,n=(t.y+e.y)/2;return new z(a,n).addvec(e.clone().sub(t).perpVector().normalize().mult(c-d))}function Qn(t,e,o,s){const r=e.clone().sub(t),d=o.clone().sub(t),c=r.length(),a=new THREE.Vector3().crossVectors(r,d);typeof s>"u"&&(s=a.dot(new THREE.Vector3(0,0,1))<0);let n=r.clone().add(d);return s&&(n=n.negate()),n=n.normalize(),t.clone().add(n.multiplyScalar(c))}_("_MEASUREGEOM",async()=>{let t,e,o=u("移动光标"),s=[];const r=()=>{s.forEach(d=>{d.erase()})};try{for(;;){const d=new j;d.setCursorType(Dt.kCross),d.disableAllTrace(),d.setDisableDynInput(!0),d.clearLastInputPoint(),d.setMessage(o);const c=`[${u("距离")}(D)/${u("半径")}(R)/${u("角度")}(A)/${u("面积")}(AR)/${u("快速")}(Q)/${u("模式")}(M)/${u("退出")}(X)]`;d.setKeyWords(c);const a=$.getCurrentMxCAD(),n=new Je,i=new ae([qt.kEntityType,"LINE,ARC,CIRCLE,LWPOLYLINE,INSERT"]),l=(g,f,h)=>{let w,m,p;for(let A=0;A<g.length;A++){let C=g[A].getMcDbEntity();if(!C)continue;if(C instanceof Zt){const v=C.blockTableRecordId.getMcDbBlockTableRecord();if(!v)continue;return l(v.getAllEntityId(),f.clone(),h.clone())}if(!(C instanceof Te))continue;const k=C.IntersectWith(new H(f,h),Re.Intersect.kOnBothOperands);if(C instanceof W&&C.isClosed){const v=C.numVerts()-1,L=C.getPointAt(0).val,V=C.getPointAt(v).val,K=new H(L,V).IntersectWith(new H(f,h),Re.Intersect.kOnBothOperands);if(!K.isEmpty()){const F=K.at(0),N=F.distanceTo(f);(typeof w>"u"||N<w)&&(m=C,w=N,p=F)}}if(k.isEmpty())continue;let E,S;k.forEach(v=>{const L=v.distanceTo(f);(typeof S>"u"||L<S)&&(S=L,E=v)}),(typeof w>"u"||S<w)&&(m=C,w=S,p=E)}if(m)return{minDistEnt:m,minDist:w,intersectPt:p}},M=(g,f)=>(n.crossingSelect(g.x,g.y,f.x,f.y,i),n.isNull()?void 0:l(n.getIds(),g,f)),D=(g,f,h,w)=>{const m=f.clone().addvec(h.clone().mult(I.viewCoordLong2Cad(16))),p=Ve.createDashedLines([f.toVector3(),m.toVector3()],8421504,.1,.1),A=f.clone().addvec(h.clone().mult(I.viewCoordLong2Cad(28)));g.drawEntity(p),g.drawText(w,I.viewCoordLong2Cad(16),0,A.toVector3())},P=(g,f,h,w,m)=>{let p;if(f instanceof W||f instanceof H){let A,b;if(f instanceof H&&(A=f.startPoint,b=f.endPoint),f instanceof W){const C=We(f,m,10);if(!C)return;const k=f.getBulgeAt(C.startIndex);if(k===0)A=C.start,b=C.end;else{const E=f.getParamAtPoint(C.start).val,S=f.getParamAtPoint(C.end).val,v=f.getDistAtParam(E).val,L=f.getDistAtParam(S).val,V=Nt(C.start,C.end,k);g.drawCircle(C.end.toVector3(),5);const{x:K,y:F}=Qn(V.toVector3(),C.start.toVector3(),C.end.toVector3()),N=new z(K,F);let U=N.clone().sub(V).normalize();const X=V.distanceTo(N);Math.abs(k)>1&&(N.addvec(V.clone().sub(N).normalize().mult(X*2)),U.negate()),D(g,N,U,Math.abs(L-v).toFixed(3))}}if(A&&b){const C=new Jn;C.pt1=A.toVector3(),C.pt2=b.toVector3(),g.drawCustomEntity(C);const k=new Ee;k.pt1=A.toVector3(),k.pt2=b.toVector3(),k.isAligned=!0,p=(S=w.x>h.x||w.y<h.y)=>{k.referenceAxis=new THREE.Vector3(0,0,S?1:-1),g.drawCustomEntity(k)};const E=new H(A,b);return{draw:p,line:E}}}if(f instanceof J){const A=new Z(-1,0,0),b=f.center.clone().addvec(A.clone().mult(f.radius));D(g,b,A,f.getLength().val.toFixed(3))}if(f instanceof ee){const b=f.getGripPoints().at(2);D(g,b,b.sub(f.center).normalize(),f.getLength().val.toFixed(3))}},y=(g,f,h,w,m)=>{if(!w||!m||w.startPoint.isEqualTo(m.startPoint)&&w.endPoint.isEqualTo(m.endPoint))return;const p=w.IntersectWith(m,Re.Intersect.kOnBothOperands);if(p.isEmpty())return;const A=new xe;A.offsetDist=0;const b=p.at(0),C=qe(w.startPoint,w.endPoint,b,f),k=qe(m.startPoint,m.endPoint,b,h);C?A.pt1=w.startPoint.toVector3():A.pt1=w.endPoint.toVector3(),k?A.pt2=m.startPoint.toVector3():A.pt2=m.endPoint.toVector3(),A.center=b.toVector3();const E=A.getAngle();if(E===Math.PI/2){g.setColor(16760576),A.radius=Math.min(I.viewCoordLong2Cad(10),Math.min(w.getLength().val,m.getLength().val)/10);const S=A.getRadius(!0),v=A.getStartPoint().clone().add(A.center.clone().sub(A.pt1).normalize().negate().multiplyScalar(S)),L=A.getEndPoint().clone().add(A.center.clone().sub(A.pt2).normalize().negate().multiplyScalar(S)),V=new THREE.Vector3(v.x+L.x-A.center.x,v.y+L.y-A.center.y);g.drawLine(v,V),g.drawLine(L,V)}else A.radius=I.viewCoordLong2Cad(26),g.drawCustomEntity(A);return E},x=(g,f,h,w,m,p)=>{const A=new H(f,h),b=new H(f,w),C=new H(f,m),k=new H(f,p),E=M(f,h),S=M(f,w),v=M(f,m),L=M(f,p);E&&(A.endPoint=E.intersectPt),S&&(b.endPoint=S.intersectPt),v&&(C.endPoint=v.intersectPt),L&&(k.endPoint=L.intersectPt),g.setColor(16777215);const{line:V,draw:K}=E&&P(g,E.minDistEnt,f,h,E.intersectPt)||{},{line:F,draw:N}=S&&P(g,S.minDistEnt,f,w,S.intersectPt)||{},{line:U,draw:X}=v&&P(g,v.minDistEnt,f,m,v.intersectPt)||{},{line:q,draw:Y}=L&&P(g,L.minDistEnt,f,p,L.intersectPt)||{},ge=E&&v&&y(g,E.intersectPt,v.intersectPt,V,U),de=E&&L&&y(g,E.intersectPt,L.intersectPt,V,q),ie=S&&v&&y(g,S.intersectPt,v.intersectPt,F,U),oe=S&&L&&y(g,S.intersectPt,L.intersectPt,F,q);E&&S&&y(g,E.intersectPt,S.intersectPt,V,F),v&&L&&y(g,v.intersectPt,L.intersectPt,U,q);const ce=Math.PI/2,ye=ge===ce&&de===ce&&ie===ce&&oe===ce;function we(O){return O.startPoint.x===O.endPoint.x?1/0:(O.endPoint.y-O.startPoint.y)/(O.endPoint.x-O.startPoint.x)}const te=(O,se)=>{const Ie=we(O),be=we(se);return Ie===be},Me=(O,se)=>{const Ie=O.getLength().val,be=se.getLength().val;return Ie===be},ne=(O,se)=>te(O,se)&&Me(O,se),De=[];V&&De.push({line:V,draw:K,info:E}),F&&De.push({line:F,draw:N,info:S}),U&&De.push({line:U,draw:X,info:v}),q&&De.push({line:q,draw:Y,info:L}),De.reduce((O,se)=>{let Ie=!1;for(let be=0;be<O.length;be++){const at=O[be];if(ne(at[0].line,se.line)){at.push(se),Ie=!0;break}}return Ie||O.push([se]),O},[]).forEach(O=>{if(O.length===1){if(ne(O[0].line,new H(A.endPoint,b.endPoint))||ne(O[0].line,new H(C.endPoint,k.endPoint)))return;O[0].draw&&O[0].draw()}else if(!ye)if(O.length===2){if(ne(O[1].line,new H(A.endPoint,b.endPoint))||ne(O[1].line,new H(C.endPoint,k.endPoint)))return;E&&S||v&&L?(E&&S&&(E.intersectPt.distanceTo(f)<S.intersectPt.distanceTo(f)?K&&K(!0):N&&N()),v&&L&&(v.intersectPt.distanceTo(f)<L.intersectPt.distanceTo(f)?X&&X(!1):Y&&Y())):(O[0].draw&&O[0].draw(),O[1].draw&&O[1].draw())}else O.forEach(({draw:se})=>{se&&se()})}),g.setColor(16760576),g.drawMcDbEntity(A),g.drawMcDbEntity(b),g.drawMcDbEntity(C),g.drawMcDbEntity(k);const Be=I.viewCoordLong2Cad(16);if(E&&S){const O=A.endPoint.distanceTo(b.endPoint);A.endPoint.distanceTo(f)>b.endPoint.distanceTo(f)?g.drawText(O.toFixed(3),Be,0,new THREE.Vector3((f.x+A.endPoint.x)/2,(f.y+A.endPoint.y)/2)):g.drawText(O.toFixed(3),Be,0,new THREE.Vector3((f.x+b.endPoint.x)/2,(f.y+b.endPoint.y)/2))}if(v&&L){const O=C.endPoint.distanceTo(k.endPoint);C.endPoint.distanceTo(f)>k.endPoint.distanceTo(f)?g.drawText(O.toFixed(3),Be,0,new THREE.Vector3((f.x+C.endPoint.x)/2,(f.y+C.endPoint.y)/2)):g.drawText(O.toFixed(3),Be,0,new THREE.Vector3((f.x+k.endPoint.x)/2,(f.y+k.endPoint.y)/2))}};if(d.setUserDraw((g,f)=>{const h=I.viewCoordLong2Cad(a.mxdraw.getViewWidth()),w=I.viewCoordLong2Cad(a.mxdraw.getViewHeight()),m=new z(-h,g.y),p=new z(g.x+h,g.y),A=new z(g.x,g.y+w),b=new z(g.x,-w);x(f,g,m,p,A,b)}),await d.go(),t=d.keyWordPicked(),d.getStatus()===R.kCancel||d.getDetailedResult()===T.kCodeAbort||d.getDetailedResult()===T.kEcsIn)break;if((d.getDetailedResult()===T.kMouseRightIn||d.getDetailedResult()===T.kNullSpaceIn||d.getDetailedResult()===T.kNullEnterIn)&&(t=e),(t==null?void 0:t.toLocaleUpperCase())==="D"){r();const g=await Vt(!0);if(g===!1)break;const{markedLines:f}=g||{};f&&s.push(...f),await(async()=>new Promise(h=>setTimeout(h,1)))()}if((t==null?void 0:t.toLocaleUpperCase())==="R"){r();const g=await Yn(!0);if(g===!1)break;const{markedLines:f}=g||{};f&&s.push(...f),await(async()=>new Promise(h=>setTimeout(h,1)))()}if((t==null?void 0:t.toLocaleUpperCase())==="A"){r();const g=await Gn();if(g===!1)break;const{markedArcs:f}=g||{};f&&s.push(...f),await(async()=>new Promise(h=>setTimeout(h,1)))()}if((t==null?void 0:t.toLocaleUpperCase())==="AR"){r();const g=await Zn();if(g===!1)break;const{markedLines:f}=g||{};f&&s.push(...f),await(async()=>new Promise(h=>setTimeout(h,1)))()}if((t==null?void 0:t.toLocaleUpperCase())==="Q"&&r(),(t==null?void 0:t.toLocaleUpperCase())==="X")break;c.includes(t)&&t!==""&&(e=t)}}catch(d){console.warn(d)}r()});async function es(){const t=new j;t.setMessage(u("指定点"));const e=await t.go();e&&I.acutPrintf(`X = ${e.x}     Y = ${e.y}     Z = ${e.z} 
`)}_("ID",es);function re(t,e,o,s){const r=t-o,d=e-s;let c=0;return r==0?c=Math.PI/2:c=Math.atan(Math.abs(d/r)),r<0&&d>=0?c=Math.PI-c:r<0&&d<0?c=Math.PI+c:r>=0&&d<0&&(c=Math.PI*2-c),c-Math.PI}function ts(t,e,o,s=!1){let r={x:e.x-t.x,y:e.y-t.y},d={x:o.x-t.x,y:o.y-t.y},c=r.x*r.x+r.y*r.y;if(c===0||s){let a=c===0?0:(d.x*r.x+d.y*r.y)/c;return new z(t.x+r.x*a,t.y+r.y*a)}else{let a=(d.x*r.x+d.y*r.y)/c;return a<0?t:a>1?e:new z(t.x+r.x*a,t.y+r.y*a)}}function ns(t,e,o){let s={x:e.x-t.x,y:e.y-t.y},r={x:o.x-t.x,y:o.y-t.y},d=s.x*s.x+s.y*s.y;if(d===0)return o.x===t.x&&o.y===t.y;let c=(r.x*s.x+r.y*s.y)/d;return c>=0&&c<=1?!0:c<0?{isStart:!0}:{isStart:!1}}let Xe=0,Ye=0,ss=0,yt=0,wt=0;const is={DE:u("增量"),P:u("百分比"),T:u("总计"),DY:u("动态")};let Ce="DE";const ze=(t,e,o,s)=>{const r=t.getLength().val,d=t.getDistAtPoint(o).val;let c=t.getStartPoint().val,a=t.getEndPoint().val;const n=d<r/2;let i;if(t instanceof H){const l=t.startPoint,M=t.endPoint;return n?(t.startPoint=c.clone().addvec(c.sub(a).normalize().mult(e)),i=()=>{t.startPoint=l}):(t.endPoint=t.endPoint.clone().addvec(a.sub(c).normalize().mult(e)),i=()=>{t.endPoint=M}),{ent:t,fallback:i}}if(t instanceof ee){const l=t.startAngle,M=t.endAngle,D=t.clone();n?(D.startAngle=t.startAngle,D.endAngle=t.startAngle-1e-7):(D.startAngle=t.endAngle,D.endAngle=t.endAngle-1e-7);const P=D.getLength().val,y=t.center,x=t.getGripPoints().at(2);let f=B.calcBulge(c,x,a).val>0,h;if(n)if(h=D.getPointAtDist(f?P-e:e).val,f)t.startAngle=re(y.x,y.y,h.x,h.y),i=()=>{t.startAngle=l};else{const w=t.endAngle;t.startAngle=w,t.endAngle=re(y.x,y.y,h.x,h.y),i=()=>{t.startAngle=l,t.endAngle=M}}else if(h=D.getPointAtDist(f?e:P-e).val,f)t.endAngle=re(y.x,y.y,h.x,h.y),i=()=>{t.endAngle=M};else{const w=t.startAngle;t.startAngle=re(y.x,y.y,h.x,h.y),t.endAngle=w,i=()=>{t.startAngle=l,t.endAngle=M}}return{fallback:i,ent:t}}if(t instanceof _e){const l=t.clone();l.startAngle=0,l.endAngle=Math.PI*2;const D=l.getLength().val-r;if(e>D)return;const P=l.getPointAtDist(0).val,y=l.getPointAtDist(n?l.getDistAtPoint(c).val-e:l.getDistAtPoint(a).val+e).val,x=P.sub(l.center),g=y.sub(l.center),f=Math.atan2(x.y,x.x);let w=Math.atan2(g.y,g.x)-f;w<0&&(w+=2*Math.PI);const m=t.startAngle,p=t.endAngle;return n?t.startAngle=w:t.endAngle=w,{fallback:()=>{n?t.startAngle=m:t.endAngle=p},ent:t}}if(t instanceof W){if(t.isClosed)return;const l=w=>{const m=[];for(let p=0;p<w.numVerts();p++){const{val1:A,val2:b}=w.getWidthsAt(p);m.push({point:w.getPointAt(p).val,bulge:w.getBulgeAt(p),startWidth:A,endWidth:b})}return m},M=(w,m)=>{for(;w.removeVertexAt(0););for(let p=0;p<m.length;p++){const A=m[p];w.addVertexAt(A.point,A.bulge,A.startWidth,A.endWidth,p)}},D=(w,m,p)=>{const A=Nt(w,m,p),b=new ee;return b.center=A,b.radius=A.sub(w).length(),b.startAngle=re(A.x,A.y,w.x,w.y),b.endAngle=re(A.x,A.y,m.x,m.y),b},P=(w,m,p,A)=>{if(p)if(A)w.startAngle=re(w.center.x,w.center.y,m.x,m.y);else{const b=w.endAngle;w.startAngle=b,w.endAngle=re(w.center.x,w.center.y,m.x,m.y)}else if(A)w.endAngle=re(w.center.x,w.center.y,m.x,m.y);else{const b=w.startAngle;w.startAngle=re(w.center.x,w.center.y,m.x,m.y),w.endAngle=b}return w},y=(w,m,p,{startIndex:A,endIndex:b,numVerts:C})=>{const k=l(w);if(w.setPointAt(p?A:b,m),p)for(let E=0;E<A;E++)w.removeVertexAt(0);else for(let E=b+1;E<C;E++)w.removeVertexAt(b+1);return()=>M(w,k)},x=(w,m,p,{start:A,end:b,startIndex:C,endIndex:k,numVerts:E,bulge:S})=>{const v=l(w),L=D(A,b,S),V=S>0;P(L,m,p,V);const K=L.getGripPoints().at(2),F=B.calcBulge(p?m:A,K,p?b:m).val;if(w.setPointAt(p?C:k,m),w.setBulgeAt(C,F),p)for(let N=0;N<C;N++)w.removeVertexAt(0);else for(let N=k+1;N<E;N++)w.removeVertexAt(k+1);return()=>M(w,v)},g=(w,m,p,{startPoint:A,endPoint:b,numVerts:C})=>{const k=p?A.clone().addvec(A.sub(b).normalize().mult(m)):b.clone().addvec(b.sub(A).normalize().mult(m)),E=p?0:C-1,S=p?A:b;return w.setPointAt(E,k),()=>w.setPointAt(E,S)},f=(w,m,p,{startPoint:A,endPoint:b,numVerts:C,bulge:k})=>{const E=D(A,b,k),S=E.clone();S.startAngle=p?E.startAngle:E.endAngle,S.endAngle=S.startAngle-1e-7;const v=S.getLength().val,L=k>0,V=m%v,K=S.getPointAtDist(p?L?v-V:V:L?V:v-V).val;P(E,K,p,L);const F=E.getGripPoints().at(2),N=B.calcBulge(p?K:A,F,p?b:K).val,U=p?0:C-1,X=p?0:C-2,q=p?A:b,Y=k;return w.setPointAt(U,K),w.setBulgeAt(X,N),()=>{w.setPointAt(U,q),w.setBulgeAt(X,Y)}},h=t.numVerts();if(e<0){const w=n?t.getPointAtDist(Math.abs(e)).val:t.getPointAtDist(r-Math.abs(e)).val,m=We(t,w,.1);if(!m)return;const{start:p,end:A,startIndex:b,endIndex:C}=m,k=t.getBulgeAt(b),E=k===0?y(t,w,n,{startIndex:b,endIndex:C,numVerts:h}):x(t,w,n,{start:p,end:A,startIndex:b,endIndex:C,numVerts:h,bulge:k});return{ent:t,fallback:E}}else{a=n?t.getPointAt(1).val:a,c=n?c:t.getPointAt(h-2).val;const w=n?t.getBulgeAt(0):t.getBulgeAt(h-2),m=w===0?g(t,e,n,{startPoint:c,endPoint:a,numVerts:h}):f(t,e,n,{startPoint:c,endPoint:a,numVerts:h,bulge:w});return{ent:t,fallback:m}}}};_("Mx_lengthen",async()=>{let t=[];const e=new Q,o=new ae;o.AddMcDbEntityTypes("LWPOLYLINE,LINE,ARC,ELLIPSE"),e.setFilter(o);const s=async d=>{for(;;){e.setMessage(u("选择要修改的对象")),e.setKeyWords(`[${u("放弃")}(U)]`);let c;e.setUserDraw((l,M)=>{const D=B.findEntAtPoint(l.x,l.y,l.z,void 0,o);c&&c.highlight(!1),c=D.getMcDbCurve();const P=D.clone();P&&P instanceof Te&&ze(P,typeof d=="number"?d:d(P,l),l)&&(c&&c.highlight(!0),M.setColor(Number(P.trueColor.getColorValue(P.layerId))),M.drawMcDbEntity(P))});const a=await e.go();if(c&&c.highlight(!1),e.getStatus()===R.kCancel||e.getStatus()===R.kNone)return!0;if(e.isKeyWordPicked("U")){const l=t.pop();l?l==null||l.fallback():I.acutPrintf(`
`+u("命令已完全放弃"));continue}if(a===null)return!0;const n=a.getMcDbCurve();if(n===null)return!0;const i=ze(n,typeof d=="number"?d:d(n,e.pickPoint()),e.pickPoint());i&&t.push(i)}},r=async d=>{const c=a=>{if(a instanceof ee){const n=a.clone();return n.startAngle=0,n.endAngle=d,n.getLength().val}if(a instanceof _e){const n=a.clone(),i=n.getLength().val;return n.endAngle+=d,n.getLength().val-i}return 0};for(;;){e.setMessage(u("选择要修改的对象")),e.setKeyWords(`[${u("放弃")}(U)]`);let a;const n=new ae;n.AddMcDbEntityTypes("LWPOLYLINE,ARC,ELLIPSE"),e.setUserDraw((P,y)=>{const x=B.findEntAtPoint(P.x,P.y,P.z,void 0,n);a&&a.highlight(!1),a=x.getMcDbCurve();const g=x.clone();if(!g||!(g instanceof Te))return;let f=c(g);ze(g,f,P)&&(a&&a.highlight(!0),y.setColor(Number(g.trueColor.getColorValue(g.layerId))),y.drawMcDbEntity(g))});const i=await e.go();if(a&&a.highlight(!1),e.getStatus()===R.kCancel||e.getStatus()===R.kNone)return!0;if(e.isKeyWordPicked("U")){const P=t.pop();P?P==null||P.fallback():I.acutPrintf(`
`+u("命令已完全放弃"));continue}if(i===null)return!0;const l=i.getMcDbCurve();if(l===null)return!0;const M=c(l),D=ze(l,M,e.pickPoint());D&&t.push(D)}};e:for(;;){e.setMessage(`${u("选择要测量的对象")}<${is[Ce]}(DE)>`),e.setKeyWords(`[${u("增量")}(DE)/${u("百分比")}(P)/${u("总计")}(T)/${u("动态")}(DY)]`);const d=await e.go();if(e.getStatus()===R.kCancel)break;if(e.getStatus()===R.kNone){setTimeout(()=>{Ce&&I.setCommandLineInputData(Ce,13)});continue}if(e.isKeyWordPicked("DE")){Ce="DE";const a=new Pe;a.setMessage(`${u("输入长度增量")}<${Xe.toFixed(4)}>`),a.setKeyWords(`[${u("角度")}(A)]`);let n=await a.go();if(a.getStatus()===R.kCancel)break;if(a.getStatus()===R.kNone&&typeof Xe=="number"&&(n=Xe),a.isKeyWordPicked("A")){const i=new le;i.setMessage(u("输入角度增量"));let l=await i.go();if(i.getStatus()===R.kNone&&(l=ss),a.getStatus()===R.kCancel||typeof l!="number"||await r(l))break}if(typeof n=="number"){if(Xe=n,await s(n))break}else break}if(e.isKeyWordPicked("P"))for(Ce="P";;){const a=new bt;a.setMessage(`${u("输入长度百分比")}<${Ye.toFixed(4)}>`);let n=await a.go();if(a.getStatus()===R.kCancel)break e;if(a.getStatus()===R.kNone&&typeof n=="number"&&(Ye=n),typeof n=="number"){if(n<=0){I.acutPrintf(`
`+u("值必须为正且非零"));continue}if(Ye=n,await s(i=>{const l=i.getLength().val;return l/100*Ye-l}))break e}else break}if(e.isKeyWordPicked("T")){Ce="T";const a=new Pe;a.setMessage(u("指定总长度")+"<"+yt.toFixed(4)+">"),a.setKeyWords(`[${u("角度")}(A)]`);let n=await a.go();if(a.getStatus()===R.kNone&&(n=yt),a.getStatus()===R.kCancel)break;if(a.isKeyWordPicked("A")){const i=new le;i.setMessage(u("指定总角度")+"<"+wt.toFixed(4)+">");let l=await i.go();if(a.getStatus()===R.kCancel||(a.getStatus()===R.kNone&&(l=wt),typeof l!="number")||await s(M=>0))break}if(typeof n!="number"||await s(i=>n-i.getLength().val))break}if(e.isKeyWordPicked("DY")){Ce="DY";const a=(n,i,l,M,D,P)=>{if(!(n instanceof W)){if(n instanceof H){let y=0;const x=ts(n.startPoint,n.endPoint,i,!0),g=ns(n.startPoint,n.endPoint,x);if(typeof g=="object"&&g.isStart!==l){const f=n.startPoint,h=n.endPoint;return g.isStart?(n.endPoint=f,n.startPoint=x):(n.startPoint=h,n.endPoint=x),{ent:n,fallback:()=>{n.startPoint=f,n.endPoint=h}}}else return l?y=x.distanceTo(n.endPoint)-M:y=x.distanceTo(n.startPoint)-M,ze(n,y,D)}if(n instanceof ee){const y=n.startAngle,x=n.endAngle,g=n.getClosestPointTo(i,!0).val,f=n.getGripPoints().at(2);let w=B.calcBulge(n.getGripPoints().at(0),f,n.getGripPoints().at(1)).val>0;const m=n.center;let p;if(w)n.endAngle=re(m.x,m.y,g.x,g.y),p=()=>{n.endAngle=x};else{const A=n.startAngle;n.startAngle=re(m.x,m.y,g.x,g.y),n.endAngle=A,p=()=>{n.startAngle=y,n.endAngle=x}}return{ent:n,fallback:p}}if(n instanceof _e){const y=n.endAngle,x=n.center,g=Math.atan2(i.y-x.y,i.x-x.x),f=Math.atan2(n.majorAxis.y,n.majorAxis.x);let h=(g-f+Math.PI*2)%(Math.PI*2);return h<n.startAngle&&(h+=Math.PI*2),n.endAngle=h,{ent:n,fallback:()=>{n.endAngle=y}}}}};for(;;){e.setMessage(u("选择要修改的对象")),e.setKeyWords(`[${u("放弃")}(U)]`);let n;const i=await e.go();if(e.isKeyWordPicked("U")){const g=t.pop();g?g==null||g.fallback():I.acutPrintf(`
`+u("命令已完全放弃"));continue}if(e.getStatus()===R.kCancel||e.getStatus()===R.kNone)return!0;if(!i||(n=i.getMcDbCurve(),!n))continue;const l=e.pickPoint(),M=n.getLength().val,P=n.getDistAtPoint(l).val<M/2,y=new j;y.setMessage(u("指定新端点")),e.setKeyWords(`[${u("放弃")}(U)]`),y.setUserDraw((g,f)=>{if(!n)return;n.highlight(!1);const h=i.clone();h instanceof Te&&a(h,g,P,M,l)&&(n.highlight(!0),f.setColor(Number(n.trueColor.getColorValue(n.layerId))),f.drawMcDbEntity(h))});const x=await y.go();if(n&&n.highlight(!1),y.getStatus()===R.kCancel||e.getStatus()===R.kNone)return!0;if(y.isKeyWordPicked("U")){const g=t.pop();g?g==null||g.fallback():I.acutPrintf(`
`+u("命令已完全放弃"));continue}if(x===null)return!0;if(n){const g=a(n,x,P,M,l);g&&t.push(g)}}}if(!d)continue;const c=d.getMcDbCurve();c&&I.acutPrintf(`
`+u("当前长度")+": "+c.getLength().val.toFixed(4))}});_("deselect",()=>{const t=$.getCurrentMxCAD();t.mxdraw.clearMxCurrentSelect(),t.updateDisplay()});const Oe=async t=>{const{dialog:e}=vt();e.showDialog(!0,t);try{return await new Promise((o,s)=>{e.onConfirm(o),e.onCancel(s)})}catch{return[""]}},Wt=async t=>{const e=await B.userSelect(`选择需要${t?"锁定":"解锁"}图层的对象`),o=new Set,s=ue(),{setValue:r}=s,{list:d}=ve(s);e.forEach(c=>{if(c.type===ot.kMxCAD){const a=c.getMcDbEntity();if(!a)return;const n=d.value.findIndex(({name:i})=>i===a.layer);n>=0&&o.add(n)}}),r("lock",t,Array.from(o),!0)};_("_OpenAllLayer",()=>{const t=ue(),{setLayerList:e,stringifyJSON:o}=t;wn(!0),e(o())});_("_SelOffLayer",async()=>{const t=await B.userSelect("选择需要关闭图层的实体"),e=new Set,o=ue(),{setValue:s,setLayerList:r,stringifyJSON:d}=o,{list:c}=ve(o);t.forEach(a=>{if(a.type===ot.kMxCAD){const n=a.getMcDbEntity();if(!n)return;const i=c.value.findIndex(({name:l})=>l===n.layer);i>=0&&e.add(i)}}),s("visible",!1,Array.from(e)),r(d())});_("_layer_recovery",()=>{const t=ue(),{recoveryLayerStateHistory:e}=t;e()});_("_layer_putCurrent",async()=>{const t=new Q;t.setMessage("选择将使其图层将成为当前图层的对象");const e=await t.go();if(!e||!e.isValid())return;const o=e.getMcDbEntity();if(!o)return;const s=ue(),{putCurrent:r}=s,{list:d}=ve(s),c=d.value.findIndex(({name:a})=>o.layer===a);c<0||r(c)});_("_layer_matching",async()=>{const t=await B.userSelect("选择需要修改图层的对象"),e=new Q;e.setMessage("选择匹配图层的对象"),e.setKeyWords("[名称(N)]");const o=await e.go();let s="";if(e.isKeyWordPicked("N")){const{dialog:r}=vt();r.showDialog(!0);try{s=(await Oe())[0]}catch{return}}else{if(!o||!o.isValid())return;const r=o.getMcDbEntity();if(!r)return;s=r.layer}s!==""&&(t.forEach(r=>{const d=r.getMcDbEntity();d&&(d.layer=s)}),$.getCurrentMxCAD().updateDisplay())});_("_layer_setEntToCurrentLayer",async()=>{const t=await B.userSelect("选择需要修改图层的对象"),e=Ct().getCurrentlyLayerName();t.forEach(o=>{const s=o.getMcDbEntity();s&&(s.layer=e)}),$.getCurrentMxCAD().updateDisplay()});_("_layer_CopyObjectsToNewLayer",async()=>{const t=await B.userSelect("选择要复制的对象"),e=new Q;e.setMessage("选择目标图层上的对象"),e.setKeyWords("[名称(N)]");const o=await e.go();let s="";if(e.isKeyWordPicked("N"))s=(await Oe())[0];else{if(!o||!o.isValid())return;const a=o.getMcDbEntity();if(!a)return;s=a.layer}const r=new j;r.setMessage("指定基点");let d=await r.go();if(!d)return;r.setMessage("指定位移的第二个点"),r.setUserDraw((a,n)=>{t.forEach(i=>{if(!d)return;const l=i.clone();l&&(l.layer=s,l.move(d,a),n.drawMcDbEntity(l))})});let c=await r.go();t.forEach(a=>{if(!d||!c)return;const n=a.clone();if(!n)return;n.move(d,c);const l=$.getCurrentMxCAD().drawEntity(n).getMcDbEntity();l&&(l.layer=s)})});_("_layer_freeze",async()=>{const t=await B.userSelect("选择需要冻结图层的对象"),e=new Set,o=ue(),{setValue:s}=o,{list:r}=ve(o);t.forEach(d=>{if(d.type===ot.kMxCAD){const c=d.getMcDbEntity();if(!c)return;const a=r.value.findIndex(({name:n})=>n===c.layer);a>=0&&e.add(a)}}),s("freeze",!0,Array.from(e),!0)});_("_layer_thawedAll",()=>{const t=ue(),{setValue:e}=t,{list:o}=ve(t);e("freeze",!1,o.value.map((s,r)=>r),!0)});_("_layer_lock",()=>Wt(!0));_("_layer_unlock",()=>Wt(!1));_("_layer_combined",async()=>{let t,e=await B.userSelect("选择要合并的图层上的对象",null,async(n,i)=>{t=i,i.setKeyWords("[命名(N)]")}),o=[];if(t&&t.isKeyWordPicked("N"))o=await Oe({isMultiple:!0});else if(e){const n=new Set;e.forEach(i=>{const l=i.getMcDbEntity();l&&n.add(l.layer)}),o=Array.from(n)}if(o.length>0&&o[0]==="")return;I.acutPrintf(`
选定的图层:`+o.join(","));const s=new Q;s.setMessage("选择目标图层上的对象"),s.setKeyWords("名称(N)");const r=await s.go();let d="";if(s.isKeyWordPicked("N"))d=(await Oe())[0];else{if(!r||!r.isValid())return;const n=r.getMcDbEntity();if(!n)return;d=n.layer}I.acutPrintf(`
将要把`+o.length+'个图层合并到图层"'+d+'"中。');const c=new Ze;c.setMessage("是否继续?"),c.setKeyWords("[是(Y)/否(N)]");const a=await c.go();if((a==null?void 0:a.toLocaleUpperCase())==="Y"){const n=new Je;n.allSelect(),n.forEach(x=>{const g=x.getMcDbEntity();g&&o.includes(g.layer)&&(g.layer=d)});const i=ue(),{remove:l,setLayerList:M,stringifyJSON:D}=i,{list:P}=ve(i),y=o.map(x=>P.value.findIndex(g=>g.name===x));l(y),M(D())}});_("_layer_remove",async()=>{let t,e=await B.userSelect("选择要合并的图层上的对象",null,async(y,x)=>{t=x,x.setKeyWords("[命名(N)]")}),o=[];if(t&&t.isKeyWordPicked("N"))o=await Oe({isMultiple:!0});else if(e){const y=new Set;e.forEach(x=>{const g=x.getMcDbEntity();g&&y.add(g.layer)}),o=Array.from(y)}if(o.length>0&&o[0]==="")return;const s=new Ze;s.setMessage("删除图层上的对象"),s.setKeyWords("[删除(D)/不删除对象改为当前图层(C)]");const r=await s.go();if(s.getStatus()===R.kCancel)return;const d=(r==null?void 0:r.toLocaleUpperCase())==="D",c=Ct().getCurrentlyLayerName(),a=ue(),{remove:n,setLayerList:i,stringifyJSON:l}=a,{list:M}=ve(a),D=o.map(y=>M.value.findIndex(x=>x.name===y)),P=n(D);if(i(l()),!P)I.acutPrintf(`删除图层失败
命令`);else{const y=new Je;y.allSelect();const x=P.map(({name:g})=>g);y.forEach(g=>{const f=g.getMcDbEntity();f&&x.includes(f.layer)&&(d?f.erase():f.layer=c)}),I.acutPrintf(`
已删除的图层:`+x.join(",")+`"
命令`)}});const os=async()=>{var e;let t=0;for(;;){if((e=Ge.instance)!=null&&e.isDialogOpen)return;const o=new j;o.clearLastInputPoint(),o.setMessage(u("指定文字起点")+":"),o.setCursorType(Dt.kCross);const s=await o.go();if(o.getStatus()===R.kCancel)return;if(!s)continue;if(t===0){let a=new Pe;a.setMessage(u("指定文字高度")+":");let n=await a.go();if(a.getStatus()===R.kCancel||n===null)return;t=n}const r=new st;r.textString="",r.position=s,r.alignmentPoint=r.position,r.height=t;const c=$.getCurrentMxCAD().drawEntity(r).getMcDbEntity();try{await new Promise(a=>{c instanceof st&&new Ge(c,s).onClose(i=>{i||r.erase(),a()})});continue}catch(a){r.erase(),console.error(a);break}}},rs=async()=>{var t;if(!((t=Ge.instance)!=null&&t.isDialogOpen))for(;;){let e=new ae;e.AddMcDbEntityTypes("TEXT,MTEXT,CUSTOMENTITY");let o=new Q;o.setFilter(e),o.setMessage(u("选择要编辑的文字"));let s=await o.go();if(o.getStatus()===R.kCancel)return;if(!s||!s.isValid())continue;let r=s.getMcDbEntity();if(r instanceof st)try{await new Promise(d=>{new Ge(r,o.pickPoint()).onClose(a=>{d()})});continue}catch(d){console.error(d);break}}};_("Mx_EditText",rs);_("_DrawText",os);const as=async()=>{const t=$.getCurrentMxCAD(),e=new dt;e.setStyleName(Qe.currentName);let o=e.getJustification(),s=e.getScale();e.setJustification(o),e.setScale(s);let r=[];const d=(a,n)=>{if(r.length===0)return;const i=new dt;i.setJustification(o),i.setScale(s),i.setStyleName(Qe.currentName),r.forEach(l=>{i.addVertex(l)}),i.addVertex(a),n.drawMcDbEntity(i)},c=()=>{};try{for(;;){const n=new j;n.clearLastInputPoint(),n.setMessage(u("指定第一点")),n.setKeyWords(`[${u("对正")}(J)/${u("比例")}(M)/${u("样式")}(S)]`);const i=await n.go();if(n.getStatus()===R.kCancel||n.getDetailedResult()===T.kNewCommadIn)return c(),!1;if(n.isKeyWordPicked("J")){const l=new j;if(l.setMessage(u("指定对正类型")+"<"+u("无")+">"),l.setKeyWords(`[${u("上")}(T)/${u("中")}(M)/${u("下")}(B)/${u("无")}(A)]`),await l.go(),console.log(l.getStatus()),l.getStatus()===R.kNone)o=1;else if(l.getStatus()===R.kCancel)continue;if(l.getDetailedResult()===T.kNewCommadIn)return c(),!1;l.isKeyWordPicked("T")?o=0:l.isKeyWordPicked("M")?o=1:l.isKeyWordPicked("B")?o=2:l.isKeyWordPicked("A")&&(o=-1),e.setJustification(o);continue}if(n.isKeyWordPicked("M")){const l=new bt;l.setMessage(u("指定比例")+"<"+s.toString()+">");const M=await l.go();if(l.getStatus()===R.kCancel)continue;if(l.getDetailedResult()===T.kNewCommadIn)return c(),!1;if(l.getStatus()===R.kOk&&typeof M=="number"){const D=M;!isNaN(D)&&D>0&&(s=D,e.setScale(s))}continue}if(n.isKeyWordPicked("S")){const l=new Fe;l.setMessage(u("指定样式名称"));const M=await l.go();M&&Qe.keys().includes(M)&&e.setStyleName(M);continue}if(i){r.push(i.clone()),e.addVertex(i);break}}let a=!0;for(;;){const n=a?u("指定第二点"):u("指定下一点"),i=new j;i.setMessage(n),a||i.setKeyWords(r.length>2?`[${u("闭合")}(C)/${u("撤销")}(U)]`:`[${u("撤销")}(U)]`);const l=r[r.length-1];i.setBasePt(l),i.setUserDraw((D,P)=>(d(D,P),1));const M=await i.go();if(i.getDetailedResult()===T.kMouseRightIn)break;if(i.getStatus()===R.kCancel){if(r.length>1)break;return c(),!1}if(i.getDetailedResult()===T.kNewCommadIn)return c(),!1;if(i.isKeyWordPicked("U")){r.length>1&&(r.pop(),e.removeVertexAt(e.getVertexCount()-1),a=r.length===1);continue}if(i.isKeyWordPicked("C")){if(r.length>=3)return e.setIsClosed(!0),t.drawEntity(e),!0;I.acutPrintf(u(`
至少需要3个点才能闭合多线`));continue}M&&(r.push(M.clone()),e.addVertex(M),a=!1)}return r.length>=2?(t.drawEntity(e),!0):!1}catch(a){return console.error("绘制多线出错:",a),!1}finally{}},cs=async()=>(console.log(u("MLINE命令: 开始绘制多线")),await as(),!0),ls=()=>{_("MLINE",cs)};ls();Jt(()=>{new Qt().rxInit()});en();async function $t(t,e){return new Promise(async o=>{let s=t.hash,r=t.type;const d=t.file,{hideLoading:c,showLoading:a}=Pt();if(r===me()){d.source.source.size/(1024*1024)>1&&a();const i=URL.createObjectURL(d.source.source);setTimeout(()=>{Tt(i),setTimeout(()=>{URL.revokeObjectURL(i)},5e3)})}else{let{mxfilepath:i=""}=Et()||{},l=on(),M=l+i+s+"."+r+me(!0),D=l+i+s+"/___mx___tz___.dwg.mxweb",P=!1;if(!t.isUseServerExistingFile){let h=await Pn(M,s);if(!h.ok)return c(),o(!1);h.tz&&(P=!0)}rn(u("正在打开文件中")+"..."),an(!0);var n=new Date().getTime();let y=0;e||(y=et.EMSCRIPTEN_FETCH_LOAD_TO_MEMORY|et.EMSCRIPTEN_FETCH_PERSIST_FILE|et.EMSCRIPTEN_FETCH_REPLACE);let x=$.App.getCurrentMxCAD(),g=!1;cn.emit("startOpenFile");const f=x.openWebFile(M,h=>{if(c(),g=!0,ln(),h===0){o(!0);var w=new Date().getTime();if(w-n>5e3&&ke().success(u("更新显示")+"..."),P){let m=l+"/mxcad/files/tz";dn.post(m,{fileHash:s}).then(p=>{p&&p.data&&p.data.code==0&&x.getImp().loadTz(D)})}}else o(!1),ke().error(u("打开图纸失败"))},void 0,void 0,y,!P);pt(M).then(h=>{h/(1024*1024)>1&&f&&!g&&a()}),o(!!f),o(!1)}un(d.name)})}let $e=pe();_("OpenDwg",async()=>{$e=pe(),await kt(!1,"OpenDwgImp"),$e&&Ae("MxFullScreen")});_("OpenDwg_DoNotUseCache",async()=>{$e=pe(),await kt(!0,"OpenDwgImp_DoNotUseCache"),$e&&Ae("MxFullScreen")});_("OpenDwgImp_DoNotUseCache",async t=>{await $t(t,!1)});_("OpenDwgImp",async t=>{await $t(t,!0)});_("Mx_SaveAs",It);_("Mx_QSave",xn);_("Mx_Export_DWG",async()=>{{$e=pe();const t=()=>{$e&&Ae("MxFullScreen")};let{baseUrl:e="",saveDwgUrl:o="",mxfilepath:s=""}=Et()||{};e.substring(0,16)=="http://localhost"&&(e=ut()+e.substring(16)),o.substring(0,16)=="http://localhost"&&(o=ut()+o.substring(16));let r=$.getCurrentMxCAD();r.saveFileToUrl(o,(d,c)=>{try{let a=JSON.parse(c);if(a.ret=="ok"){let n=e+s+a.file;fetch(n).then(async i=>{const l=await i.blob();let M=r.getCurrentOriginaFileName();function D(P){const y=P.toLowerCase(),x=y.lastIndexOf(".");if(x!==-1){const g=y.substring(x);if(g===me(!0))return P.substring(0,x)+".dwg";if(g===".dwg"||g===".dxf")return P}return P+".dwg"}M=D(M),await ht.saveAsFileDialog({blob:l,filename:M,types:[{description:"dwg"+u("图纸"),accept:{"application/octet-stream":[".dwg"]}}]}),t()})}else console.log(c)}catch{console.log("Mx: sserverResult error")}})}});_("Mx_debug",()=>{});_("Mx_clear_buf",()=>{});_("Mx_Array",gn);_("Mx_NewFile",()=>{tn().open({title:u("新建"),text:u("是否新建一个文件")+"?",cancelTitle:u("取消"),defineTitle:u("确定"),define:()=>{$.getCurrentMxCAD().newFile();const{initLayerList:e}=ue(),{initColorIndexList:o}=mt(),{initLineTypeList:s}=nn();e(),o(),s()}})});_("Mx_NewFile_Template",()=>{$.getCurrentMxCAD().openWebFile("empty_template.mxweb")});_("MxPE_DrawMText_old",async()=>{const t=new j;t.setMessage(u("点取文字插入点"));const e=await t.go();if(!e)return;const{open:o}=hn(),s=await o();if(typeof s=="boolean")return;const{text:r,size:d}=s,c=new sn;c.contents=r||"",d&&(c.textHeight=d),c.location=e;const a=$.getCurrentMxCAD(),n=a.drawEntity(c);return a.updateDisplay(),n});
